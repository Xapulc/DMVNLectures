\documentclass[a4paper]{article}
\usepackage{dmvn}

\newcommand{\tal}{\wt{\al}}
\newcommand{\tbe}{\wt{\be}}
\newcommand{\tsi}{\wt{\si}}

\newcommand{\X}[2]{{x_{#1} \sco x_{#2}}}
\newcommand{\Y}[2]{{y_{#1} \sco y_{#2}}}
\newcommand{\XN}[2]{{\ol{x}_{#1} \sco  \ol{x}_{#2}}}
\newcommand{\YN}[2]{{\ol{y}_{#1} \sco  \ol{y}_{#2}}}
\newcommand{\sA}[2]{{a_{#1} \sco a_{#2}}}
\newcommand{\sG}[2]{{g_{#1} \sco g_{#2}}}
\newcommand{\Al}[2]{{\al_{#1} \sco \al_{#2}}}
\newcommand{\Bt}[2]{{\be_{#1} \sco \be_{#2}}}
\newcommand{\Gm}[2]{{\ga_{#1} \sco \ga_{#2}}}
\newcommand{\Dl}[2]{{\de_{#1} \sco \de_{#2}}}
\newcommand{\Ep}[2]{{\ep_{#1} \sco \ep_{#2}}}
\newcommand{\AlN}[2]{{\ol{\al}_{#1} \sco \ol{\al}_{#2}}}

\newcommand{\AOP}[2]{{A_{#1}\oplus \dots \oplus A_{#2}}}
\newcommand{\XOP}[2]{{x_{#1}\oplus \dots \oplus x_{#2}}}

\newcommand{\XSig}[1]{{x_1^{\si_1} \dots x_{#1}^{\si_{#1}}}}

\newcommand{\nx}{\ol{x}}
\newcommand{\ny}{\ol{y}}

\newcommand{\BStd}{\hc{\neg \, \& \, \vee}}
\newcommand{\BJeg}{\hc{\oplus \, \& \, 1}}

\newcommand{\bigamp}{\mathop{\&}}

\begin{document}

\dmvntitle{Курс лекций по}{математической логике}{Лектор\т Олег Борисович Лупанов}
{I курс, 2 семестр, поток математиков}{Москва, 2004 г.}

\pagebreak

\tableofcontents
\pagebreak

\subsection*{Предисловие}

Данный документ представляет собой курс лекций <<Введение в  математическую логику>>, читаемый деканом
механико-математического факультета МГУ академиком РАН О.\,Б.\,Лупановым на I курсе мехмата во втором
семестре. Он наиболее соответствует лекциям, прочитанным в 2001 и 2003 годах, поскольку составлялся на их
основе. В указанные годы в программу из-за недостатка времени не вошла теорема Кузнецова, поэтому здесь
её тоже нет, а  всё остальное изложено в полном объёме.

Надо сказать, что этот документ не является своего рода первоисточником. Основой для него послужил тот же курс
лекций по логике, набранный в MS Word студентом мехмата с псевдонимом VILenin. Но так как математические
тексты в Word'е выглядят не самым лучшим образом, мы решили улучшить VILenin'ский вариант.
Лекции, свёрстанные заново в \LaTeX'е, выглядят гораздо красивее и имеют существенно меньший объём.
Кроме того, мы исправили все замеченные опечатки, уточнили некоторые определения и доказательства некоторых
теорем. Насколько хорошо это получилось\т пусть судит читатель, и любые обоснованные замечания будут приняты
нами с благодарностью, равно как и любые сообщения о замеченных в нашем издании опечатках.
То, что Вы читаете сейчас, условно можно назвать третьим изданием. В нём заново сделаны иллюстрации,
исправлены замеченные типографские погрешности, а также ещё несколько опечаток.

В тексте мы старались не использовать нестандартных обозначений, символов \итд Начало и конец доказательства
отмечаются значками $\square$ и $\blacksquare$ соответственно.

Свои вопросы, комментарии, замечания и предложения направляйте на \dmvnmail{}, а обновления
электронной версии документа находится на \dmvnwebsite{}.

Остаётся пожелать читателю успехов при изучении математической логики, а также удачи на экзамене, ежели
таковой придётся сдавать.

\bigskip

\hfill Набор и вёрстка: \texttt{DMVN Corporation}

\hfill Последняя редакция: \texttt{\сегодня~г.}

\pagebreak

\section{Булева алгебра}

\subsection{Функции булевой алгебры}

Пусть $\B = \hc{0,1}$. Рассмотрим функции вида $f: \mathbb{B}^n \ra \mathbb{B}$. Они называются \emph{булевыми}
функциями или функциями \emph{алгебры логики}. Множество всех таких функций обозначается $P_2$. Любую такую функцию
можно задать таблицей:

\ctab{ccccc|c}{
$x_1$ & $x_2$ & \dots & $x_{n-1}$ & $x_n$ & $f(\X{1}{n})$      \\ \hline
0     & 0     & \dots & 0         &  0    & $f(0,0 \sco 0,0)$ \\
0     & 0     & \dots & 0         &  1    & $f(0,0 \sco 0,1)$ \\
\dots & \dots & \dots & \dots     & \dots & \dots              \\
1     & 1     & \dots & 1         & 1     & $f(1,1 \sco 1,1)$}

Слева расположены всевозможные наборы значений переменных (всего их $2^n$), а справа значение функции на этом наборе
(0 или 1). Всего функций от $n$ переменных будет $p_2(n) = 2^{2^n}$. Для экономии места иногда удобно функцию $n$
переменных задавать строкой из $2^n$ чисел\т значений функции, записанных в том порядке, в каком они были бы
расположены в последнем столбце таблицы. Рассмотрим подробнее эти функции.

$\bullet\quad n=1$. Здесь всего будет 4 функции:
\ctab{c||c|c|c|c}{
$x$ & 0 & $x$ & $\nx$ & 1 \\ \hline
0   & 0 & 0   & 1     & 1 \\
1   & 0 & 1   & 0     & 1}

Здесь $0, 1$\т константы, $x$\т тождественная функция, $\nx$\т \emph{отрицание} $x$.

$\bullet\quad n=2$. Здесь будет 16 функций. Выпишем некоторые:
\ctab{cc||c|c|c|c|c|c}{
$x_1$ & $x_2$ & $x_1 \& x_2$ & $x_1 \vee x_2$ & $x_1 \oplus x_2$ & $x_1 \ra x_2$ & $x_1 / x_2$ & $x_1 \downarrow x_2$\\ \hline
0 & 0 & 0 & 0 & 0 & 1 & 1 & 1\\
0 & 1 & 0 & 1 & 1 & 1 & 1 & 0\\
1 & 0 & 0 & 1 & 1 & 0 & 1 & 0\\
1 & 1 & 1 & 1 & 0 & 1 & 0 & 0}

Здесь $x_1 \& x_2$\т \emph{конъюнкция} или логическое И, $x_1 \vee x_2$\т \emph{дизъюнкция} или логическое ИЛИ,
$x_1 \oplus x_2$\т сумма по модулю 2, $x_1 \ra x_2$\т \emph{импликация}, $x_1/x_2$\т \emph{штрих Шеффера},
$x_1 \downarrow x_2$\т \emph{стрелка Пирса}.

\subsection{Существенные и несущественные переменные}

\begin{df}
Функция $f(\X{1}{n})$ называется \emph{существенно зависящей} от переменной $x_i$, если существуют два
набора значений переменных $\wt{\al}_0=(\Al{1}{i-1},0,\Al{i+1}{n})$ и
$\wt{\al}_1= (\Al{1}{i-1},1,\Al{i+1}{n})$, отличающиеся только значением переменной $x_i$, такие, что
$f(\wt{\al}_0) \neq f(\wt{\al}_1)$. В этом случае говорят, что $x_i$\т \emph{существенная переменная}.
Переменная $x_i$ называется \emph{несущественной}, если она не является
существенной, \те для любых двух наборов такого вида имеем $f(\wt{\al}_0) = f(\wt{\al}_1)$.
\end{df}

\begin{ex}
Конъюнкция существенно зависит от переменной $x_1$, так как $(0 \& 1) \neq (1 \& 1)$.
\end{ex}

Если функция $f(\X{1}{n})$ несущественно зависит от $x_i$, то
$$f(\Al{1}{i-1},0,\Al{i+1}{n})=\beta, \quad f(\Al{1}{i-1},1,\Al{i+1}{n})=\beta.$$
Её таблица имеет следующий вид:
\ctab{ccccccc|c}{
$x_1$ & \dots & $x_{i-1}$ & $x_i$ & $x_{i+1}$ & \dots & $x_n$ & $f(\X{1}{n})$ \\ \hline
& & & \dots & & & & \dots \\
$\al_1$ & \dots & $\al_{i-1}$ & 0 & $\al_{i+1}$ & \dots & $\al_n$ & $\beta$ \\
& & & \dots & & & & \dots \\
$\al_1$ & \dots & $\al_{i-1}$ & 1 & $\al_{i+1}$ & \dots & $\al_n$ & $\beta$ \\
& & & \dots & & & & \dots}
Вычеркнем все наборы, у которых $x_i=1$, и $i$-й столбец, получим новую функцию
$g(\X{1}{i-1},\X{i+1}{n})$, такую что $g(\Al{1}{i-1},\Al{i+1}{n})= f(\Al{1}{i-1},0,\Al{i+1}{n})$. Её таблица имеет вид
\ctab{cccccc|c}{
$x_1$ & \dots & $x_{i-1}$ & $x_{i+1}$ & \dots & $x_n$ & $g(\X{1}{i-1},\X{i+1}{n})$ \\ \hline
& & \dots & \dots & & & \dots \\
$\al_1$ & \dots & $\al_{i-1}$ & $\al_{i+1}$ & \dots & $\al_n$ & $f(\Al{1}{i-1},0,\Al{i+1}{n})$ \\
& & \dots & \dots & & & \dots}
\noindent Говорят, что функция $g$ получилась из функции $f$ \emph{отбрасыванием несущественной переменной} $x_i$.

Аналогично можно и добавлять несущественные переменные. Пусть дана функция $f(\X{1}{n})$, построим
новую функцию $h(\X{1}{n},x_{n+1})=f(\X{1}{n})$. Тогда $x_{n+1}$ будет несущественной переменной функции $h$,
действительно, $h(\Al{1}{n},0)= f(\Al{1}{n})=h(\Al{1}{n},1)$. Говорят, что функция $h$ получилась из функции
$f$ добавлением несущественной переменной $x_{n+1}$.

\begin{df}
Функции $h_1$ и $h_2$ называются \emph{равными}, если одна получена из другой в результате
добавления и отбрасывания несущественных переменных.
\end{df}

\begin{ex}
Пусть дана функция $h_1(x_1,x_2)$, несущественно зависящая от переменной $x_1$, отбросим её, получим функцию $g(x_2)$, добавим
несущественную переменную $x_3$, получим функцию $h_2(x_2,x_3)$. Функции $h_1$ и $h_2$ равны, хотя таблицы у них разные!

\begin{center}
\begin{tabular}{|cc|c|} \hline $x_1$ & $x_2$ & $h_1(x_1,x_2)$ \\ \hline 0 & 0 & 0 \\ 0 & 1 & 1 \\ 1 & 0 & 0 \\ 1 & 1 & 1 \\ \hline \end{tabular}
$\ra$
\begin{tabular}{|c|c|} \hline $x_2$ & $g(x_2)$ \\ \hline 0 & 0 \\ 1 & 1 \\ \hline \end{tabular}
$\ra$
\begin{tabular}{|cc|c|} \hline $x_2$ & $x_3$ & $h_2(x_2,x_3)$ \\ \hline 0 & 0 & 0 \\ 0 & 1 & 0 \\ 1 & 0 & 1 \\ 1 & 1 & 1 \\ \hline \end{tabular}
\end{center}
\end{ex}

\subsection{Формулы}

\begin{df}
Пусть дано некоторое множество функций $\Fc=\hc{f_1(\X{1}{n_1}) \sco f_s(\X{1}{n_s}), \dots}$.
Определим понятие \emph{формулы над множеством} $\Fc$ индуктивно. Функции $f_i(\X{1}{n_i})$ являются
формулами над $\Fc$. Если $A_1 \sco A_{n_i}$\т переменные или формулы над $\Fc$, то
$f_i(A_1 \sco A_{n_i})$ тоже является формулой над $\Fc$.
\end{df}

\begin{ex}
$\Fc= \hc{\ph(x_1,x_2)}$, тогда $\ph(x_1,x_2)$ и $\ph\br{x_2,\ph(x_3,x_4)}$ будут
формулами над $\Fc$, а $\ph(x_1,x_2,x_3)$\т нет.
\end{ex}

Значение переменной $x_i$ на наборе $R=(\Al{1}{s})$ равно $\al_i$. Пусть уже определены
$A_1\evn{R} \sco A_{n_i}\evn{R}$. Тогда
\eqn{f_i\hr{A_1 \sco A_{n_i}}\evn{R} = f_i\Br{A_1\evn{R} \sco A_{n_i}\evn{R}}.}
Отсюда следует, что любая формула выражает некоторую функцию.

\begin{df}
Формулы называются \emph{эквивалентными (равными)}, если они выражают равные функции.
\end{df}

Рассмотрим множество функций $\Fc=\hc{x_1 \& x_2, \, x_1 \vee x_2, \, \nx_1, \, x_1}$. Примеры равных формул над $\Fc$:

\equ{x_1 \& x_2=x_2 \& x_1, \quad x_1 \vee x_1 = x_1, \quad \ol{x_1 \& x_2}=\nx_1 \vee \nx_2, \quad (x_1 \vee x_2) \& x_3 =
(x_1 \& x_3) \vee (x_2 \& x_3).}

Введём ещё одну полезную функцию:
\eqn{x^\si:=\case{x, & \si=1; \\ \nx, & \si=0.}}
Заметим, что $x^\si=1 \Lra x=\si$. В самом деле, $x^1=1 \; \Lra \; x=1$, и $x^0=\nx=1 \; \Lra \; x=0$.

Введём соглашения по записи формул. Знак $\&$ можно не писать, как умножение в алгебре. Для ассоциативных операций внутренние скобки
писать не будем: $\Bigl(\br{(x_1\vee x_2)\vee x_3}\vee\br{x_4\vee x_5}\Bigr)=(x_1\vee x_2\vee x_3\vee x_4 \vee x_5)$.
Внешние скобки также можно опускать и писать $x_1 \oplus x_2$ вместо $(x_1 \oplus x_2)$. Иногда будем использовать для записи
отрицания знак $\neg x=\nx$, а для конъюнкции\т знак <<$\wg$>>. Введём сокращения:
\equ{A_1 \& \dots \& A_n = \bigamp\limits_{i=1}^n A_i, \quad A_1 \vee \dots \vee A_n = \bigvee\limits_{i=1}^n A_i,
\quad \AOP{1}{n} = \sum\limits_{i=1}^n A_i.}

\subsection{СДНФ}

Рассмотрим формулу $\XSig{n}$. Она равна единице только на одном наборе $(\si_1\sco \si_n)$.

\begin{theorem}[О разложении функции по переменным]
Дана функция $f(\X{1}{n})$ и число $1 \le k \le n$.
Имеет место формула для $f$ над множеством $\hc{\vee, \, \&, \, \neg, \, f(\X{1}{n}), \, 0, \, 1}$:
\eqn{\label{FunctionDecomposition}f=\bigvee_{(\si_1\sco\si_k)} x_1^{\si_1} \sd x_k^{\si_k} f(\si_1\sco\si_k,\X{k+1}{n}).}
\end{theorem}
\begin{proof}
Возьмём произвольный набор $\tal = (\Al{1}{n})$ и найдём значение формулы на этом наборе. В том случае, когда
$(\Al{1}{k})=(\si_1\sco\si_k)$, имеем $\al_1^{\si_1} \sd \al_k^{\si_k} f(\si_1\sco\si_k,\Al{k+1}{n})=f(\tal)$. Если
$(\si_1\sco\si_k) \bw \neq (\Al{1}{k})$, то $\al_1^{\si_1} \sd \al_k^{\si_k} f(\si_1 \sco \si_k ,\Al{k+1}{n})=0$. Следовательно, расписав $(\ref{FunctionDecomposition})$ по всем наборам, получим
$0 \sv 0 \vee f(\X{1}{n}) \vee 0 \sv 0=f(\X{1}{n})$.
\end{proof}

Рассмотрим два частных случая для числа $k$.

\pt{1} $k=1$. $f(\X{1}{n})=\nx_1 f(0,x_2 \sco x_n)\vee x_1f(1,x_2 \sco x_n)$.

\pt{2} $k=n$. Для дизъюнкции надо брать лишь наборы $\tsi=(\si_1 \sco \si_n )$, для которых $f(\tsi)=1$, так как все остальные
дизъюнкты обнулятся:
$$f(\X{1}{n})=\bigvee_{\tsi: \; f(\tsi)=1} \XSig{n}.$$
Это формула для $f$ над $\BStd$. Она называется \emph{совершенной дизъюнктивной нормальной формой (СДНФ)}.

\begin{ex}
$x \ra y = \nx\,\ny\vee\nx\vee xy$, $x \oplus y=\nx y \vee x\ny$, $x \sim y =\nx\,\ny \vee xy$, где $x \sim
y=(1001)$.
\end{ex}

\subsection{Полнота систем функций}

\begin{df}
Система $\Fc$ называется \emph{полной}, если любая функция из $P_2$ выражается формулой над $\Fc$.
\end{df}

\begin{theorem}[Достаточное условие полноты]
Пусть дана полная система $\Fc$, и любая функция из $\Fc$ выражается формулой над системой $\Gc$. Тогда
$\Gc$\т полная.
\end{theorem}
\begin{proof}
Пусть $\Fc=\hc{f_1,f_2,\dots}$ и $F_i$\т формулы над $\Gc$, выражающие функции $f_i$ соответственно.
Возьмём произвольную функцию $f \in P_2$, тогда существует формула $F_0$ над $\Fc$, выражающая эту функцию.
Заменим в формуле каждую из функций $f_i$ на соответствующую ей формулу $F_i$, и получим формулу над
$\Gc$, выражающую функцию $f$. Значит, любая функция из $P_2$ выражается формулой над $\Gc$,
поэтому система $\Gc$\т полная.
\end{proof}

\begin{theorem}
Из любой полной системы можно выделить конечную полную подсистему.
\end{theorem}

\begin{proof}
Пусть $\Fc$\т полная система (возможно, бесконечная), тогда существуют формулы над $\Fc$, выражающие
функции $\neg, \&, \vee$. В каждую из этих формул входит конечное число функций из $\Fc$, значит, эти
функции образуют конечную подсистему $\Gc$. Так как функции $\neg, \&, \vee$ выражаются формулами
над $\Gc$, а $\BStd$\т полная система, то $\Gc$ будет конечной полной подсистемой.
\end{proof}

Используя достаточное условие полноты, построим ещё несколько полных систем:

1. $\hc{\& \, \neg}$. Действительно, конъюнкция и отрицание у нас есть. Так как
$x_1\vee x_2 = \ol{\nx_1 \& \nx_2}$, то и дизъюнкция тоже есть. Значит, система полная.

2. $\hc{\vee \, \neg}$. Аналогично, так как $x_1\& x_2=\ol{\nx_1 \vee \nx_2}$.

3. $\BJeg$. Конъюнкция уже есть, отрицание выразим так: $\nx = x \oplus 1$. Значит, система полная.

4. $\hc{/}$\т штрих Шеффера: $\nx = x/x$, а $x_1 \& x_2 =\ol{x_1/x_2}=(x_1/x_2)\bigl/(x_1/x_2)$.
Значит, система является полной.

5. $\hc{\downarrow}$\т стрелка Пирса\т тоже полная система. Доказательство\т аналогично предыдущему.

\subsection{Полиномы Жегалкина}

Рассмотрим конъюнкции вида $x_{i_1} \dots x_{i_k}$, где все $i_1 \sco i_k$\т различны. Также  будем
рассматривать конъюнкции длины 1 (\те переменные) и константу 1 (конъюнкцию длины 0).

\begin{df}
Сумма по модулю 2 попарно различных коньюнкций $$\sum_{(i_1, \dots, i_k)}x_{i_1}\dots x_{i_k}$$ называется
\emph{полиномом Жегалкина}. Пустой полином Жегалкина по определению выражает нулевую функцию. \emph{Степенью} полинома
называется максимальная длина конъюнкций переменных, входящих в него.
\end{df}

\begin{theorem}[Жегалкина]
Любая функция алгебры логики представима в
виде полинома Жегалкина единственным образом с точностью до перестановки слагаемых и перестановки множителей
в слагаемых.
\end{theorem}

\begin{proof}
Представимость. Так как $\BJeg$\т полная система, то любая функция
представима формулой над $\BJeg$. Приведём эту формулу к полиному Жегалкина:

\pt{1} Раскроем все скобки, применив дистрибутивный закон $(A \oplus B)C=AC \oplus BC$. Тогда формула приведётся к сумме
конъюнкций $\AOP{1}{s}$.

\pt{2} Так как $xx=x$, то, если в каком-либо произведении встречаются повторяющиеся переменные, можно  оставить
только один экземпляр.

\pt{3} Уничтожим лишние единицы: $x \& 1 = x$, поэтому если в каком-либо произведении встречаются единицы, можно их
убрать (лишь в случае произведения только из единиц оставим одну единицу).

\pt{4} Приведём подобные: $x \oplus x=0$, значит, если есть повторяющиеся слагаемые, оба экземпляра можно убрать. Если
пропадут все слагаемые, это будет пустой полином.

В итоге мы получим полином Жегалкина. Тем самым представимость доказана.

Единственность. Поскольку в любое произведение любая переменная может входить или не  входить,
то всего различных произведений из $n$ переменных будет $2^n$, но из них нужно убрать нулевое произведение и
добавить константу 1, \те всего рассматриваемых нами произведений будет тоже $2^n$. Так как в полиноме любое
произведение может присутствовать или не присутствовать, всего различных полиномов (включая пустой) будет
ровно $2^{2^n}$, \те столько же, сколько всех функций в $P_2(n)$. Поэтому, если какая-нибудь функция
представима в виде двух различных полиномов Жегалкина, то какая-то функция не будет представима в этом виде,
что невозможно.
\end{proof}

\subsection{Замкнутые классы функций}

\begin{df}
\emph{Замыканием} системы $\Fc$ называется множество $[\Fc]$, состоящее из всех функций,  выражаемых формулой
над $\Fc$. Система $\Fc$ называется \emph{замкнутой}, если $\Fc=[\Fc]$.
\end{df}

Свойства операции замыкания:

\pt{1} $\Fc \subseteq [\Fc]$.

\pt{2} $\Fc_1 \subseteq \Fc_2 \Ra [\Fc_1] \subseteq [\Fc_2]$.

\pt{3} $[\Fc_1 \cup \Fc_2] \supseteq [\Fc_1] \cup [\Fc_2]$.

\pt{4} $\bigl[[\Fc]\bigl]=[\Fc]$.

\pt{5} Если $\Fc$\т полная система, то $[\Fc]=P_2$.

\begin{df}
Функции, представимые полиномами Жегалкина первой степени, называются \emph{линейными}.
\end{df}

Линейные функции имеют вид $\XOP{1}{k}\oplus c$, где $c \in \mathbb{B}$.  Их множество
обозначается через $\Lb$. Оно, очевидно, является замкнутым. Это множество нетривиально,
\те $\Lb \neq \varnothing, \Lb \neq P_2$.

\begin{lemma}[О нелинейной функции]
Из любой нелинейной функции, подставляя вместо некоторых переменных  константы,
и, может быть, отрицание переменных, и, может быть, навешивая отрицание на результат, можно получить
конъюнкцию двух переменных.
\end{lemma}

\begin{proof}
Пусть $f(\X{1}{n}) \notin \Lb$, тогда в её полиноме Жегалкина есть
произведение длины больше 1. Возьмём самое короткое из них, переставим его на первое место: $f(\X{1}{n})=x_1
\dots x_p \oplus \dots, \quad p \geqslant 2$.

Каждое другое нелинейное произведение содержит хотя бы одну переменную, отличную от $\X{1}{p}$.  Вместо этих
переменных, кроме $\X{1}{p}$, подставим 0, тогда все остальные нелинейные конъюнкции обратятся в 0, и
останется $f(\X{1}{p},0 \sco 0)=x_1\dots x_p \oplus l(\X{1}{p})$, где $l(\X{1}{p})$\т линейная функция от
переменных $\X{1}{p}$. Оставим первые две переменные, а вместо остальных (если они есть) подставим 1, получим
$f(x_1,x_2,1 \sco 1,0 \sco 0)=x_1x_2\oplus l(x_1,x_2)=x_1x_2 \oplus \al x_1\oplus \beta x_2 \oplus \gamma$.
Сделаем следующую подстановку: вместо $x_1$ подставим $x_1 \oplus \beta$ (это будет либо $x_1$, либо $\nx_1$),
$x_2$ заменим на $x_2 \oplus \al$ и прибавим ко всей функции $(\al\beta \oplus \gamma)$, \те либо ничего не
изменим, либо навесим отрицание на результат. В итоге получится следующая функция: $(x_1 \oplus \beta)(x_2
\oplus \al) \oplus \al(x_1 \oplus \beta) \oplus \beta(x_2 \oplus \al) \oplus \gamma \oplus (\al\beta \oplus
\gamma)$. После раскрытия скобок получим $x_1x_2 \oplus \al x_1 \oplus \beta x_2 \oplus \al\beta \oplus \al
x_1 \oplus \al\beta \oplus \beta x_2 \oplus \al\beta \oplus \gamma \oplus \al\beta \oplus \gamma = x_1 x_2$.
\end{proof}

\begin{imp}
Если $f \notin \Lb$, то $\& \in \bs{\hc{f,0,1,\neg}}$.
\end{imp}

Рассмотрим ещё два замкнутых класса:

\pt{1} Класс $\Tb_0$ функций, таких, что $f(0 \sco 0)=0$. Очевидно, что это множество нетривиально.

\begin{stm}
Класс $\Tb_0$ замкнут.
\end{stm}

\begin{proof}
Сами переменные принадлежат этому множеству: если $f(x)=x$, то
$f(0)=0$. Поэтому  достаточно доказать, что если $f(\X{1}{n}) \in \Tb_0$ и $f_1 \sco f_n \in \Tb_0$, то и
$f\hr{f_1 \sco f_n} \in \Tb_0$. Поскольку $f_i(0 \sco 0)=0$, то $f\br{f_1(0 \sco 0) \sco f_n(0 \sco 0)}=f(0 \sco 0)=0$. Следовательно, класс $\Tb_0$ замкнут.\
\end{proof}

\pt{2} Класс $\Tb_1$ функций, таких, что $f(1 \sco 1)=1$. Этот класс тоже нетривиален и замкнут.

\begin{df}
Функция $f^*(\X{1}{n}) := \ol{f(\nx_1 \sco \nx_n)}$ называется \emph{двойственной} к $f(\X{1}{n})$.
Функция $f$ называется \emph{самодвойственной}, если $f^*=f$.
\end{df}

\begin{ex}
$x^*=\ol{\ol x}=x$, $\ol{x}^*=\ol{\ol{\ol x}}=\ol{x}$, $(x_1x_2)^*=\ol{\nx_1\,\nx_2}=x_1 \vee x_2$,
$(x_1 \vee x_2)^* = x_1x_2$, $0^*=\ol{0}=1$, $1^*=\ol{1}=0$.
\end{ex}

Множество самодвойственных функций обозначается через $\Sb$. Очевидно, что $\Sb$ нетривиально.

\begin{stm}
Класс $\Sb$ замкнут.
\end{stm}
\begin{proof}
Ясно, что переменные входят в $\Sb$, поэтому нам опять достаточно
доказать, что если $f(\X{1}{n}) \in \Sb$ и $f_1 \sco f_n \in \Sb$, то и $f\hr{f_1 \sco f_n} \in \Sb$. Можно
считать, что у всех функций $f_i$ одинаковый набор переменных, поскольку если это не так, то недостающие
переменные можно добавить как несущественные. Пусть этот набор\т $\Y{1}{m}$. Пусть
$g(\Y{1}{m})=f\br{f_1(\Y{1}{m}) \sco f_n(\Y{1}{m})}$. Тогда
\begin{multline*}
  g^*(\Y{1}{m})=\ol{f\br{f_1(\YN{1}{m}) \sco f_n(\YN{1}{m})}} =
  \ol{f\hr{\ol{\ol{f_1(\YN{1}{m})}}  \sco \ol{\ol{f_n(\YN{1}{m})}}}}= \\
  =\ol{f\Bigl(\ol{f^*_1(\Y{1}{m})} \sco \ol{f^*_n(\Y{1}{m})}\Bigl)} =
  f^*\br{f^*_1(\Y{1}{m}) \sco f^*_n(\Y{1}{m})}=g(\Y{1}{m}),
\end{multline*}
поскольку $f, f_1 \sco f_n \in \Sb$.
\end{proof}

\begin{note}
Пусть $f(\X{1}{n}) \in \Sb$, тогда
\equ{\ol{f(\XN{1}{n})}=f(\X{1}{n}) \; \Lra \; \ol{\ol{f(\XN{1}{n})}} =
\ol{f(\X{1}{n})} \; \Lra \; f(\XN{1}{n})=\ol{f(\X{1}{n})},}
\те на противоположных наборах переменных значения функции  противоположны.
\end{note}

\begin{lemma}[О несамодвойственной функции]
Пусть $f(\X{1}{n}) \notin \Sb$, тогда, подставляя в неё вместо
переменной $x_i$ переменную $x$ или $\nx$, можно получить константу.
\end{lemma}
\begin{proof}
Поскольку $f(\X{1}{n}) \notin
\Sb$, то существует пара противоположных наборов $(\Al{1}{n})$ и $(\AlN{1}{n})$:
$f(\Al{1}{n})=f(\AlN{1}{n})$. Заменим $x_i$ на $x_i \oplus \al_i$, \те вместо $x_i$ поставим либо $x_i$,
либо $\ol{x}_i$, и получим функцию $h(x)=f(x\oplus \al_1 \sco x \oplus \al_n)$, а поскольку
$h(0)=f(\Al{1}{n})$, $h(1)=f(\AlN{1}{n})$, получаем, что $h(0)=h(1)$, \те $h(x)$ является константой.
\end{proof}

\begin{imp}
Если $f \notin \Sb$, то $\hc{0, \, 1} \subset \bs{\hc{f, \neg}}$.
\end{imp}
\begin{proof}
По лемме одна из констант уже есть. С помощью отрицания можно получить и вторую константу.
\end{proof}

Введём \emph{правило сравнения наборов}. Будем говорить, что $(\Al{1}{n}) \le (\Bt{1}{n})$, если
$\al_i \le \be_i, \; i = \ol{1,\,n}$. При этом мы считаем, что $0 \le 0$, $0 \le 1$, $1 \le 1$, но $1 \nle 0$.
Теперь мы можем упорядочить  (частично!) все наборы: $$(0 \sco 0) \le (\Al{1}{n}) \le (1 \sco 1).$$

\begin{df}
Функция $f(\X{1}{n})$ называется \emph{монотонной}, если $\fa \; (\Al{1}{n}) \le (\Bt{1}{n})$  имеем
$f(\Al{1}{n}) \le f(\Bt{1}{n})$. Множество всех монотонных функций обозначается $\Mb$.
\end{df}

\begin{ex}
Функции $0, \; 1, \; x, \; x_1x_2$ монотонны (это видно из таблицы), а функции $\nx, \; \ol{x_1 x_2}$\т нет.
\end{ex}

Как мы видим из примеров, множество функций $\Mb$ нетривиально.

\begin{stm}
Класс $\Mb$ замкнут.
\end{stm}
\begin{proof}
Переменные принадлежат этому множеству, значит, достаточно доказать, что из $f(\X{1}{n}) \in
\Mb$ и $f_1 \sco f_n \in \Mb$ следует, что $f\hr{f_1 \sco f_n} \in \Mb$. Будем считать, что $f_1 \sco f_n$\т функции от одного набора переменных $\Y{1}{m}$, иначе добавим их как несущественные. В силу монотонности
функций $f_i$ для любых двух наборов $\tal=(\Al{1}{m}) \le (\Bt{1}{m})=\tbe$ будем иметь, что
$f_i(\tal) \le f_i(\tbe)$, \те $\br{f_1(\tal) \sco f_n(\tal)} \le \br{f_1(\tbe) \sco
f_n(\tbe)}$, но так как $f$ монотонна, то $f\br{f_1(\tal) \sco f_n(\tal)} \le
f\br{f_1(\tbe) \sco f_n(\tbe)}$ $\Ra$ $f\hr{f_1 \sco f_n} \in \Mb$.
\end{proof}

\begin{lemma}[о немонотонной функции]
Из любой немонотонной функции, подставляя вместо некоторых ее переменных
константы, можно получить отрицание.
\end{lemma}
\begin{proof}
Пусть $f(\X{1}{n}) \notin \Mb$. Тогда существуют два набора
$\tal=(\Al{1}{n}) \le (\Bt{1}{n}) = \tbe$, такие, что $f(\tal) \nle f(\tbe)$, \те $f(\tal)=1$ и
$f(\tbe)=0$. Поэтому наборы $\tal$ и $\tbe$ разные. Переставим те переменные, по которым они отличаются, на
первые места, тогда эти наборы превратятся в $(\ub{0,0 \sco 0}_m,\Al{m+1}{n})$ и $(\ub{1,1 \sco 1}_m, \Bt{m+1}{n})$. Будем последовательно заменять в наборе с нулями в начале эти нули на единицы,
тогда рано или поздно наступит момент, при котором значение функции сменится на противоположное, поскольку на
наборе с единицами значение функции противоположное. Значит, зафиксировав все переменные, кроме той, на
которой произошла смена значения, мы получим отрицание.
\end{proof}

\subsection{Критерий Поста полноты систем функций}

\begin{df}
\emph{Базис} системы функций $\Fc$\т такая подсистема $\Bc \subseteq \Fc$, что $\Fc \subseteq [\Bc]$,  и
ни одной функции из~$\Bc$ выкинуть нельзя.
\end{df}

\begin{theorem}[Критерий Поста]
Система $\Fc$ полна тогда и только тогда, когда она не содержится целиком ни в одном из классов $\Tb_0$,
$\Tb_1$, $\Lb$, $\Sb$, $\Mb$.
\end{theorem}
\begin{proof}
Необходимость. Если $\Fc$ целиком содержится в каком-либо из этих классов, то и $[\Fc]$ содержится в
нём и потому не совпадает с $P_2$, а значит, система $\Fc$ неполная.

Достаточность. Так как $\Fc \nsubseteq \Tb_0$, то найдется $f_0 \in \Fc$, не лежащая в $\Tb_0$.
Аналогично в $\Fc$ найдутся $f_1 \notin \Tb_1$, $f_L \notin \Lb$, $f_S \notin \Sb$, $f_M \notin \Mb$. Сейчас
мы получим из них константы, отрицание и конъюнкцию. Поскольку $f_0 \notin \Tb_0$, имеем $f(0 \sco 0)=1$.
Положим $\ph(x):= f(x \sco x) \Ra \ph(0)=1$. Если $\ph(1)=1$, то это константа
1, а функция $\psi(x) := f_1 \hr{\ph(x) \sco \ph(x)}$\т константа 0. Если же
$\ph(1)=0$, то $\ph(x)=\nx$, и по лемме о несамодвойственной функции при помощи отрицания можно
получить обе константы. По лемме о немонотонной функции из $f_M$, имея константы, можно получить отрицание.
По лемме о нелинейной функции при помощи констант и отрицания можно получить конъюнкцию. Таким образом, мы
выделили в $\Fc$ полную подсистему, а значит, $[\Fc]=P_2$.
\end{proof}

\begin{imp}
Из любой полной системы можно выделить полную подсистему, состоящую из 5 функций.
\end{imp}
\begin{proof}
Достаточно взять функции $f_0, f_1, f_\Lb, f_\Sb, f_\Mb$.
\end{proof}

\begin{theorem}
Можно обойтись и 4 функциями, но меньшего количества в общем случае уже не хватит.
\end{theorem}
\begin{proof}
Докажем, что 4 функций достаточно. В случае, когда $\ph(x)=1$ (здесь $\ph$\т  функция из предыдущей теоремы),
это несамодвойственная функция, и можно обойтись без $f_\Sb$. Если же $\ph(x)=\nx$, это немонотонная функция,
можно обойтись без $f_\Mb$.

Приведём пример базиса из 4 функций: $\Fc = \hc{0, \, 1, \, x_1 x_2, \, x_1 \oplus x_2 \oplus x_3}$.
Имеем $1 \notin \Tb_0, \; 0 \notin \Tb_1, \; x_1x_2 \notin \Lb, \; 0 \notin \Sb, \; x_1 \oplus x_2 \oplus x_3 \notin \Mb$.
Функция $x_1 \oplus x_2 \oplus x_3$ немонотонная, т.к. из неё можно получить отрицание: $\nx = 1
\oplus 0 \oplus x$. Она самодвойственная, т.к. $(x_1 \oplus x_2 \oplus x_3)^* = x_1 \oplus 1 \oplus x_2
\oplus 1 \oplus x_3 \oplus 1 \oplus 1 = x_1 \oplus x_2 \oplus x_3$. Отсюда следует, что $[\Fc]=P_2$, но ни
одну функцию из $\Fc$ выкинуть нельзя, так как все, кроме 0, входят в $\Tb_1$; все, кроме 1, входят в $\Tb_0$;
все, кроме $x_1 x_2$, входят в $\Lb$; и все, кроме $x_1 \oplus x_2 \oplus x_3$, входят в $\Mb$.
\end{proof}

\begin{lemma}
Для любых двух классов среди $\Tb_0$, $\Tb_1$, $\Lb$, $\Sb$, $\Mb$ существует функция, принадлежащая
одному и не принадлежащая другому.
\end{lemma}
\vskip-10pt
\rightfloatingbox{\tab{|c|c|c|c|c|c|}{
\hline       & $\Tb_0$ & $\Tb_1$ & $\Lb$  & $\Sb$ & $\Mb$          \\ \hline
$\Tb_0$ &   & 0 & $\&$ & 0 & $x_1 \oplus x_2$ \\
\hline $\Tb_1$ & 1     &       & $\&$ & 1     & $x_1 \ra x_2$  \\ \hline
$\Lb$ & 1 & 0 &        & 1 & $x_1 \oplus x_2$ \\
\hline $\Sb$ & $\nx$ & $\nx$ & $\psi$ &       & $\nx$          \\ \hline
$\Mb$ & 1 & 0 & $\&$ & 1 &                  \\ \hline}}
\begin{proof}
\hangindent=-60mm
\hangafter=-5
Просто предъявим требуемые функции для всех пяти классов. В таблице в каждой клетке стоит функция,
принадлежащая классу строки и не принадлежащая классу столбца. Функцию $\psi$ определим следующим образом:
$\psi(x_1,x_2,x_3) \bw{:=} (0,0,0,1,0,1,1,1)$.
Проверим её свойства: очевидно, что она самодвойственная (вспомните определение!). Она нелинейная, так как $\psi(0,x_2,x_3)=x_2 x_3$.
\end{proof}

\begin{theorem}
Пусть $\Ac=[\Ac], \Ac \neq P_2 \Ra \Ac$ содержится в одном из пяти  классов $\Tb_0, \Tb_1, \Lb,
\Sb, \Mb$.
\end{theorem}

\begin{proof}
Пусть $\Ac$ не содержится ни в одном из этих классов. По критерию Поста
$\Ac=[\Ac]=P_2$. Противоречие.
\end{proof}

\begin{df}
$\Fc$ называется \emph{предполным} классом, если $\Fc = [\Fc] \neq P_2$ и
$\fa \; f \notin \Fc$ имеем $\bs{\hc{\Fc, f}}=P_2$.
\end{df}

\begin{theorem}
В $P_2$ существует ровно 5 предполных
классов $\Tb_0, \Tb_1, \Lb, \Sb, \Mb$, и других нет.
\end{theorem}

\begin{proof}
Докажем, что любой из этих классов (например, $\Sb$)
-- предполный. Первые два условия, очевидно, выполнены. По предыдущей лемме в нём есть функции, не
принадлежащие $\Tb_0, \Tb_1, \Lb, \Mb$ соответственно, а тогда $\fa \; f \notin \Sb$ в системе $\Sb \cup
\hc{f}$ есть функции, не принадлежащие ни одному из этих классов. Значит, $\Sb$\т предполный класс.

Теперь докажем, что других предполных классов нет. Допустим, $\Ac=[\Ac] \neq P_2$, и $\Ac$ не
совпадает ни с одним из этих пяти классов. Тогда по предыдущей теореме $\Ac$ содержится в одном из них
(обозначим его через $\Xc$). $\Ac \neq \Xc, \Ac \subseteq \Xc \Ra \exi \; f \notin \Ac, f
\in \Xc \Ra \Ac \cup \hc{f} \subseteq \Xc \Ra \Bigl[\Ac \cup \hc{f} \Bigr] \subseteq \Xc \neq
P_2$. Значит, система $\Ac \cup \hc{f}$ неполная, а тогда по определению $\Ac$\т не предполный класс.
\end{proof}

\begin{theorem}[E.\,Post]
В $P_2$ имеется счётное множество замкнутых классов.\footnote{Доказательства этой теоремы в нашем курсе не будет.}
\end{theorem}

\section{$k$-значная логика}

\subsection{Функции $k$-значной логики}

Аналогично функциям двузначной логики можно определить функции $k$-значной логики. Значения переменных  и
самих функций лежат в множестве $\hc{0,1 \sco k-1}$. Множество всех таких функций обозначается через $P_k$.
Аналогично эти функции можно задавать таблицей:

\ctab{ccc|c}{
$x_1$   & \dots & $x_n$   & $f(\X{1}{n})$  \\ \hline
    0   & \dots & 0       & $f(0 \sco 0)$  \\
        & \dots &         & \dots          \\
$\al_1$ & \dots & $\al_n$ & $f(\al_1 \sco \al_n)$ \\
        & \dots &         & \dots          \\
$k-1$   & \dots & $k-1$   & $f(k-1 \sco k-1)$}

Количество различных наборов значений равно $k^n$, на каждом наборе функция может принимать $k$ значений,
следовательно, всего функций будет $p_k(n)=k^{k^n}$. Понятия формулы, значения формулы, существенной
зависимости, полноты и т.д. вводятся также, как в булевой алгебре. Однако есть и существенные отличия.
Приведём одно из них. В двузначной логике имеет место следующее

\begin{stm}
Пусть $f(\X{1}{n})$ и  $g(\Y{1}{m})$ существенно зависят от всех своих переменных. Тогда функция
$h(\X{1}{n-1}, \Y{1}{m}) := f\br{\X{1}{n-1},g(\Y{1}{m})}$ также существенно зависит от всех своих переменных.
\end{stm}
\begin{proof}
Все переменные равноправны, поэтому достаточно доказать утверждение для $x_1$ и $y_m$.
Переменная $x_1$\т существенная для $f$, поэтому найдутся наборы $\wt{\al}_0=(0, \Al{2}{n})$ и
$\wt{\al}_1=(1, \Al{2}{n})$, такие, что $f(\wt{\al}_0) \bw\neq f(\wt{\al}_1)$. Но
так как $g \neq \const$, то найдётся набор $\wt{\be}$, такой, что $g(\wt{\be}) = \al_n$.
Значит, $f \br{0,\Al{2}{n-1},g(\wt{\be})} \bw= f(\wt{\al}_0) \bw\neq f(\wt{\al}_1) \bw=
f\br{1,\Al{2}{n-1},g(\wt{\beta})}$. Значит, $h$ существенно зависит от $x_1$. Поскольку $f$
существенно зависит от $x_n$, то найдутся наборы $\wt{\ga}_0=(\Gm{1}{n-1},0)$ и $\wt{\ga}_1=(\Gm{1}{n-1},1)$, такие, что
$f(\wt{\ga}_0) \neq f(\wt{\ga}_1)$. Аналогично найдутся $\wt{\de}_0=(\Dl{1}{m-1},0)$ и $\wt{\de}_1=(\Dl{1}{m-1},1)$,
такие, что $g(\wt{\de}_0) \neq g(\wt{\de}_1)$. Тогда $h$ обнаруживает существенную
зависимость от $y_m$ на наборах $(\Gm{1}{n-1}, \Dl{1}{m-1},0)$ и $(\Gm{1}{n-1}, \Dl{1}{m-1},1)$.
\end{proof}

Это утверждение перестаёт быть верным в $k$-значной логике при $k=3$. Рассмотрим функцию
$\ph(x,y)\bw=(0,0,0,0,0,0,0,0,1)$, которая равна 1 только на наборе $(2,2)$. Тогда
$\ph\br{x,\ph(y,z)}$\т константа 0, потому что для любых $y$ и $z$ имеем $\ph(y,z) \neq 2$.

Интересными для рассмотрения функциями в $k$-значной логике являются:
\begin{items}{-3}
\item Константы $0,1 \sco k-1$;
\item Тождественная функция $x$;
\item Аналоги отрицания $x+1 \pmod{k}$ и $N(x) := k-1-x$;
\item Аналоги функции $x^\si$: $J_\si(x) := \case{k-1, &x=\si; \\ 0, & x \neq \si}$ и
      $j_\si(x) := \case{1, & x=\si; \\ 0, & x \neq \si}$
\item Аналоги конъюнкции $\min(x_1,x_2)$ (далее\т $\&$) и $x_1x_2 \pmod{k}$;
\item Аналоги дизъюнкции $\max(x_1,x_2)$ (далее\т $\vee$) и $x_1+x_2 \pmod{k}$.
\end{items}

\subsection{Полнота систем функций в $P_k$}

\begin{stm}
Система $\hc{0,1 \sco k-1 \, J_0(x) \sco J_{k-1}(x) \, \min(x_1,x_2) \, \max(x_1,x_2)}$\т полная.
\end{stm}

\begin{proof}
В $P_k$ имеет место аналог СДНФ:
$$f(\X{1}{n})=\bigvee_{(\si_1 \sco \si_n )} J_{\si_1}(x_1) \sa J_{\si_n}(x_n) \& f(\si_1 \sco \si_n ).$$

Действительно, подставим $(\Al{1}{n})$ в $f$ и проверим равенство. Если $(\Al{1}{n})=(\si_1 \sco \si_n )$, то имеем
$J_{\si_1}(\al_1) \sa J_{\si_n}(\al_n) \& f(\si_1 \sco \si_n ) = f(\si_1 \sco \si_n )$, поскольку
$J_{\si_i}(\si_i) = k-1$\т максимально возможному значению. Если же $(\Al{1}{n}) \neq (\si_1 \sco \si_n )
\Ra \exi i\cln \si_i \neq \al_i \Ra J_{\si_i}(\al_i) = 0$\т минимально возможному значению,
следовательно, $J_{\si_1}(\al_1) \sa J_{\si_n}(\al_n) \& f(\si_1 \sco \si_n ) = 0$. Значит,
формула верна и мы предъявили явное выражение для произвольной функции над заданным множеством.
\end{proof}

\begin{imp}
Для любого $k$ существуют конечные полные системы.
\end{imp}

\begin{stm}
Система $\hc{x+1 \pmod{k}, \max(x_1,x_2)}$\т полная.
\end{stm}

\begin{proof}
Здесь и далее арифметические операции подразумеваются по модулю $k$ (для краткости). Из
функции  $x+1$ многократным применением можно получить функцию вида $x+c$, где $c$\т константа. Далее,
заметим, что $\max\br{x,x+1 \sco x+(k-1)} = k-1$. Из этой константы можно получить все остальные.
Теперь рассмотрим функцию $\ph_t(x) := \max\br{x, x+1, \dots, x+(t-1),x+(t+1) \sco
x+(k-1)}+1$ и заметим, что
$$\ph_t(x)=\case{k-1, & x=k-1-t; \\ 0, & x \neq k-1-t,} \text{~то есть~} \ph_t(x) = J_{k-1-t}(x).$$

Функцию $\min(x_1,x_2)$ выразим так: $\min(x_1,x_2)\bw=N\br{\max\hr{N(x_1),N(x_2)}}$, применив аналог
правила Де~Моргана $x_1 x_2 = \ol{\ol{x}_1 \vee \ol{x}_2}$. Покажем, как получить любую функцию
одной  переменной. Построим функции вида
$$\ph_{\al,\beta}(x) := \case{\beta, & x=\al \\0, & x \neq \al.}$$
Такие функции можно выразить формулой $\ph_{\al,\beta}(x)=\max(J_{\al}(x), k-(\beta+1))+\beta+1$.  Тогда
любая функция $\psi(x) \in P_k(1)$ выражается формулой $\psi(x)=\max(\ph_{0,\psi(0)},
\ph_{1,\psi(1)}, \dots,  \ph_{k-1,\psi(k-1)})$. Таким образом мы можем получить $N(x)$. Следовательно, наша система полная.
\end{proof}

\begin{stm}
Система $\hc{V(x) := \max(x_1,x_2)+1}$\т полная.
\end{stm}

\begin{proof}
Функция $V(x)$ является аналогом штриха
Шеффера и называется \emph{функцией Вебба}. В самом деле,  $V(x,x)=x+1 \Ra $ можно получить функцию вида
$x+c$. Возьмем $c=k-1$. Тогда $V(x_1,x_2) + k - 1 = \max(x_1,x_2)$, а полученные функции образуют базис $P_k$.
\end{proof}

\begin{theorem}
Для любого $k$ в $P_k$ существует конечное число предполных классов $A_1,\dots A_q$. $[\Fc]=P_k
\bw\Lra \Fc \nsubseteq A_i \; \fa i=\ol{1,\,q}$. Доказательства этой теоремы в нашем курсе не будет.
\end{theorem}

Пусть $\pi(k)$\т количество предполных классов в $P_k$. Вот их количество при разных $k$:

\ctab{|c|c|c|c|c|c|}{ \hline $k$ & 2 & 3 & 4 & 5 & 6 \\ \hline $\pi(k)$ & 5 & 18 & 80 & 667 & 15237 \\ \hline}

Справедлива асимптотическая формула:
$$\pi(k) \backsimeq \delta(k) \cdot k \cdot 2^{\mathbf{C}^m_{k-1}}, \quad m = \hs{\frac{k-1}{2}}, \quad \delta(k) =
\case{1, & k \equiv 1 \pmod{2}; \\ 2, & k \equiv 0 \pmod{2}.}$$

Рассмотрим алгоритм распознавания полноты в $P_k$. Пусть $\Fc=\hc{f_1(\X{1}{n_1}), \dots, f_s(\X{1}{n_s}),
\dots}$. Возьмём переменные $x_1$ и $x_2$ и  построим последовательность множеств $\Pi_i$ по следующему
правилу: $\Pi_1=\es; \; \Pi_{i+1}\bw=\Pi_i \cup \hc{f_j(A_1, \dots, A_{n_j})}$, где $A_k \in \hc{x_1, x_2} \cup \Pi_i$.
Тогда $\Pi_1 \subseteq \Pi_2 \subseteq \Pi_3 \subseteq \dots \subseteq P_k(2)$, но так как
$|P_k(2)| < \infty$, то начиная с некоторого момента $\Pi_t = \Pi_{t+1} = \Pi_{t+2} = \dots$. Очевидно, что
$[\Fc] = P_k \Lra V(x_1,x_2) \in \Pi_t$.

\subsection{Критерии полноты в $P_k$. Теорема Слупецкого\ч Яблонского}

\begin{df}
$f(\X{1}{n}) \in P_k(n)$\т \emph{существенная} функция, если она зависит не менее, чем от 2 переменных и
принимает $k$ значений.
\end{df}

\begin{theorem}[Слупецкого\ч Яблонского]
Пусть $\Fc \supseteq P_k(1)$. $[\Fc]=P_k \Lra \Fc$ содержит существенную функцию. Усиление С.\,В.\,Яблонского:
тот же самый вывод исходя из предположения о том, что $\Fc$ содержит все функции одной переменной,
принимающие не более $k-1$ значения.
\end{theorem}

\begin{proof}
$\Ra$ Будет доказано для случая Слупецкого. Предположим, что $\Fc$ содержит все функции от одной
переменной и ни одной существенной. Тогда покажем, что $\Fc$ неполная. В самом деле, любая формула над $\Fc$
имеет вид $f_{i_1}(f_{i_2}(\dots f_{i_l}(g(x_{l_1},x_{l_2},\dots))\dots))$, где $f_{i_j} \in P_k(1)$, а $g$\т
самая внешняя в этой формуле среди всех функций более чем одной переменной. Но $g$ не является
существенной функцией по предположению, значит, она принимает не более $k-1$ значения. Но тогда и вся формула
не может принимать больше $k-1$ значения, следовательно, любая функция над $\Fc$ принимает не более $k-1$
значения. Значит, $\Fc$\т неполная.

$\Leftarrow$ Докажем для случая Яблонского, а значит и для случая Слупецкого. Пусть $k \geqslant 3$.  Нам
понадобится

\begin{lemma}[о трёх наборах]
Пусть $f \in P_k(n)$ существенно зависит не менее, чем от 2 переменных и
принимает не менее 3 значений. Тогда существуют 3 набора
\begin{align*}
A &= (\al,\Al{2}{n}), \\
B &= (\be,\Al{2}{n}), \\
C &= (\al,\Dl{2}{n}),
\end{align*}
такие, что $f(A) \neq f(B) \neq f(C)$.
\end{lemma}
\begin{proof}
Для определенности будем считать, что $f$ существенно зависит от переменной $x_1$. Следовательно,
найдутся наборы $\tal = (\al,\Al{2}{n})$ и $\tbe = (\beta,\Al{2}{n})$, такие что $f(\tal)=\ep_1$, $f(\tbe) = \ep_2$,
причём $\ep_1 \neq \ep_2$. Рассмотрим множество наборов $\Mc=\hc{(0,\Al{2}{n}),(1,\Al{2}{n})\sco(k-1,\Al{2}{n})}$.
Возможны 2 случая:

\pt{1} Если среди $f(\Mc)$ имеется только 2 различных значения, то по условию существует набор
$\wt\de = (\de,\Dl{2}{n})$, такой, что $f(\wt\de) \neq \ep_1, f(\wt\de) \neq \ep_2$. Тогда $(\de, \Al{2}{n}) \in \Mc$, и
$f(\delta, \Al{2}{n}) \in \hc{\ep_1, \ep_2}$. Пусть, для определенности, $f(\de, \Al{2}{n}) = \ep_1$.
Тогда найдётся $\ga$, такое что $f(\ga, \Al{2}{n}) = \ep_2$. Таким образом, искомые наборы\т
\equ{\mat{(\de, \Al{2}{n}), \\ (\ga,\Al{2}{n}),\\ (\de,\Dl{2}{n}).}}

\pt{2} Среди $f(\Mc)$ имеется не менее 3 различных значений. Среди  функций
\equ{f(0,\X{2}{n})\sco f(k-1,\X{2}{n})}
хотя бы одна\т не константа, поскольку $f$ существенно зависит не только от $x_1$. Пусть
$f(\al,\X{2}{n})$\т не константа. Тогда найдётся набор $(\Dl{2}{n})$, такой, что $\ep_1 = f(\al, \Dl{2}{n})
\neq f(\al,\Al{2}{n})=\ep_2$, но в силу существенной зависимости от $x_1$ существует $\be\cln f(\beta,
\Al{2}{n})=\ep_3$.
\end{proof}

\begin{df}
\emph{Квадрат}\т это четыре набора вида
$$\mat{
(\Al{1}{i-1}, \; \al, \; \Al{i+1}{j-1}, \; \be, \; \Al{j+1}{n}),\\
(\Al{1}{i-1}, \; \ga, \; \Al{i+1}{j-1}, \; \be, \; \Al{j+1}{n}),\\
(\Al{1}{i-1}, \; \al, \; \Al{i+1}{j-1}, \; \de, \; \Al{j+1}{n}),\\
(\Al{1}{i-1}, \; \ga, \; \Al{i+1}{j-1}, \; \de, \; \Al{j+1}{n}),}$$
где $\al \neq \ga, \; \be \neq \de$.
\end{df}

\begin{lemma}[о квадрате]
Пусть $f$ существенно зависит не менее, чем от 2 переменных, и принимает  не менее 3
значений. Тогда существует квадрат, на котором одно значение принимается ровно 1 раз.
\end{lemma}

\begin{proof}
По лемме о трёх
наборах существуют наборы
\begin{align*}
\wt{\si}_1 = (\al_1, \Al{2}{n}), \quad f(\wt{\si}_1) = \ep_1, \\
\wt{\si}_2 = (\de_1, \Al{2}{n}), \quad f(\wt{\si}_2) = \ep_2, \\
\wt{\si}_3 = (\de_1, \Dl{2}{n}), \quad f(\wt{\si}_3) = \ep_3,
\end{align*}
причем $\ep_1 \neq \ep_2 \neq \ep_3$. Построим цепочку квадратов

$$\begin{pmatrix}
\al_1 & \al_2 & \al_3 & \al_4 & \dots & \al_n \\ \delta_1 & \al_2 & \al_3 & \al_4 & \dots & \al_n \\
\al_1 & \delta_2 & \al_3 & \al_4 & \dots & \al_n \\ \delta_1 & \delta_2 & \al_3 & \al_4 & \dots & \al_n \\
\al_1 & \delta_2 & \delta_3 & \al_4 & \dots & \al_n \\ \delta_1 & \delta_2 & \delta_3 & \al_4 & \dots & \al_n \\
\dots   & \dots   & \dots   & \dots   & \dots & \dots        \\ \delta_1 & \delta_2 & \delta_3 & \delta_4 & \dots & \delta_n \\
\end{pmatrix}$$
Здесь первый квадрат\т это строки $[1 \dots 4]$, второй\т $[3 \dots 6]$, третий\т $[5 \dots 8]$, \итд На
первых двух наборах значения функции равны соответственно $\ep_1$ и $\ep_2$, а на последнем\т $\ep_3$.
Значит, рано или поздно в последовательности квадратов появится квадрат, на котором одно из значений
$\ep_1, \, \ep_2, \, \ep_3$ принимается ровно 1 раз.
\end{proof}

Приступим к доказательству основной теоремы. Сначала построим все функции, принимающие ровно 2  значения, а
затем по индукции из всех функций, принимающих не более $l$ значений, получим все функции, принимающие $l+1$
значение. По условию, у нас есть существенная функция $f$. Поскольку $k \geqslant 3$, она удовлетворяет
условиям леммы о квадрате. Рассмотрим наборы, образующие квадрат, на котором какое-то значение, скажем,
$\ep_1$, принимается ровно 1 раз, \те $\ep_1 \notin \hc{\ep_2,\ep_3,\ep_4}$:
$$\mat{
f(\al & \beta & \al_3 & \dots & \al_n)= \ep_1 \\ f(\gamma & \beta & \al_3 & \dots & \al_n)= \ep_2 \\
f(\al & \delta & \al_3 & \dots & \al_n)= \ep_3 \\ f(\gamma & \delta & \al_3 & \dots & \al_n)= \ep_4}$$

Введем обозначение $\ph(x_1,x_2) := f(x_1,x_2,\Al{3}{n})$. Теперь рассмотрим функции:
\equ{\psi(x) := \case{0, & x=\ep_1\\1; & x\neq \ep_1,} \quad
\la_1(x) := \case{\al, & x=0;\\\ga, & x\neq 0,} \quad
\la_2(x) := \case{\be, & x=0;\\\de, & x \neq 0,} \quad
\om(x_1,x_2) := \psi\bs{\ph\br{\la_1(x_1), \la_2(x_2)}}.}
 Все эти функции у нас есть, поскольку они
принимают не более 2 (а значит, и не более $k-1$) значений. Заметим, что на наборах из нулей и единиц функция
$\omega$ ведёт себя так же, как обычная дизъюнкция,  поэтому обозначим её через $\wt{\bigvee}(x_1,x_2)$. Кроме того,
у нас есть функция $j_\al(x) := \case{1, x=\al \\0, x \neq \al,}$ так как она принимает только 2
значения. Построим функцию $\wt{\&}(x_1,x_2) := j_0\bs{\omega\br{j_0(x),j_0(x_2)}}$,
которая на наборах из нулей и единиц ведет себя как обычная конъюнкция. Функции $\wt{\bigvee}$ и $\wt{\&}$ позволяют
соорудить аналог СДНФ и получить все функции, которые на наборах из 0 и 1 принимают значения 0 и 1, \те все
функции из $P_2 \subset P_k$. Теперь с помощью этих функций получим функцию, которая принимает любые 2
значения (а не только 0 и 1). Пусть $h(\X{1}{m})$ принимает только значения $\al$ и $\beta$. По условию у нас
есть $\mu(x) := \case{\al, & x = 0; \\ \be, & x \neq 0.}$ Но у нас есть и $g(\X{1}{m}) :=
\case{0, & h(\X{1}{m})=\al; \\1, & h(\X{1}{m})=\be,}$ тогда $h(\X{1}{m}) = \mu\br{g(\X{1}{m})}$. Таким
образом, мы умеем делать функции, принимающие любые 2 значения.

Теперь из функций, принимающих не более $l-1$ значения, получим функции, принимающие $l$ значений.  Пусть
$g(\X{1}{m})$ принимает значения $\hc{\Ep{1}{l}}$. Из леммы о трех наборах следует существование такой
совокупности наборов, что
\eqn{\mat{
         f(\al_{\phantom{11}} & \al_{2\phantom{2}} & \dots & \al_{n\phantom{4}}) = \ep_1 \\
         f(\be_{\phantom{11}} & \al_{2\phantom{2}} & \dots & \al_{n\phantom{4}}) = \ep_2 \\
         f(\al_{\phantom{11}} & \de_{2\phantom{2}} & \dots & \de_{n\phantom{4}}) = \ep_3 \\
         f(\be_{41}           & \be_{42}           & \dots & \be_{4n}          ) = \ep_4 \\
                              &                    & \dots &                     \\
         f(\be_{l1}           & \be_{l2}           & \dots & \be_{ln}          ) = \ep_l
}}
В каждом столбце этой матрицы наборов стоит не более $l-1$ различных значений. Значения
$\ep_1,\ep_2,\ep_3$  фигурируют в лемме о трех наборах и все различны. Функция $f$\т существенная и
потому принимает $k$ значений. Следовательно, значения $\Ep{4}{l}$ мы можем выбрать так, чтобы все $\ep_i$
были различны. Покажем, как можно получить произвольную функцию, принимающую эти же $l$ значений. Нам нужно
получить функцию $g(\X{1}{m})$ такую, что $\Img g \subseteq \hc{\Ep{1}{l}}$. Каждому набору $\wt{\si}=(\si_1 \sco \si_m )$
сопоставим число (индекс) $i(\wt{\si}) \in \hc{1,2 \sco l}: g(\wt{\si})=\ep_{i(\wt{\si})}$. Построим $n$ функций
$h_j(\wt{\si}): h_j(\X{1}{m})=\beta_{i(\wt{\si})j}$, где элемент $\beta_{ij}$ соответствует $ij$-тому элементу
приведённой выше матрицы наборов. Функции $h_j$ у нас есть по предположению индукции, т.к. принимают не более
$l-1$ значения. Тогда функция $g$ выражается формулой $g=f(h_1 \sco h_n)=f\br{\beta_{i(\wt{\si})1} \sco
\beta_{i(\wt{\si})n}}$. Таким образом, мы можем получить любую функцию, принимающую значения
$\hc{\Ep{1}{l}}$, и шаг индукции доказан.

Завершим доказательство теоремы построением произвольной функции $g$, принимающей любые  $l$ значений
$\hc{\xi_1 \sco \xi_l}$. Рассмотрим функцию $\theta(x): \theta(\ep_i)=\xi_i$. Чтобы $\theta$ принимала не
более $l$ различных значений, положим $\theta(x) = \xi_1, \; x \notin \hc{\Ep{1}{l}}$. Так можно сделать,
поскольку значения функции $\theta$ не на $\ep_i$ нас не интересуют. У нас уже есть функция $h:
h(\wt{\si})=\ep_i$, если $g(\wt{\si})=\xi_i$. Тогда функция $g$ выражается так: $g=\theta(h)$.
\end{proof}

\begin{df}
Функция $f$ называется \emph{шефферовой}, если $\bs{\hc{f}}=P_k$.
\end{df}

\begin{theorem}
$f$\т шефферова $\Lra$ $f$ порождает все функции из $P_k(1)$, принимающие не более $k-1$ значения.
\end{theorem}
\begin{proof}
\fbox{$\Ra$} Тривиально: эта функция порождает все функции.

\fbox{$\Leftarrow$} Покажем, что эта функция существенна. Обозначим $\Ec := \hc{0,1 \sco k-1}$.  Если
$\Img f \neq \Ec$, то из нее нельзя получить функцию, принимающую отсутствующее значение, а среди функций
от одной переменной такая обязательно найдется. Значит, $f$ должна принимать все $k$ значений. Если она
существенно зависит только от одной переменной, то, следовательно, является перестановкой, а композиция
перестановок\т тоже перестановка, значит, константу из неё получить нельзя. Значит, она существенно зависит
не менее чем от 2 переменных, и по определению существенна. По теореме Яблонского $\bs{\hc{f}}=P_k$.
\end{proof}

Далее речь пойдет об алгебраической системе функций в $P_k$. Сложение и умножение, естественно,
подразумеваются по модулю $k$.

\begin{stm}
Система $\Ec \cup \hc{\times \, +}$ полная $\Lra$ $k$\т простое число.
\end{stm}

\begin{proof}
Пусть $k$\т простое число. Положим $\ph(x) := 1-x^{k-1}$. Имеем $\ph(0)=1$, а
по малой теореме Ферма $\ph(a)\equiv 0 \pmod{k}$, если $a \neq 0$. Следовательно, $\ph = j_0$. Легко
видеть, что $j_\al(x)=j_0(x-\al)$. Но так как для любой функции $f$ мы имеем полиномиальное выражение над
$\Ec \cup \hc{\times \, + \, j_0(x), \dots, j_{k-1}(x)}$ вида
$$f(\X{1}{n})=\sum_{(\si_1 \sco \si_n )} j_{\si_1}(x_1) \times \dots \times j_{\si_n}(x_n)
\times f(\si_1 \sco \si_n ),$$  то система полная.

Предположим теперь, что $k$\т составное число, \те $k=mn$ и $m,n>1$, и докажем, что наша система  неполная.
Покажем, что $j_0(x)$ не представляется в виде полинома $j_0(x)=c_0+c_1x+c_2x^2+\dots+c_px^p$. Т.к.
$j_0(0)=1$, то $c_0=1$. Но в силу того, что $m \neq 0$, имеем $0 =j_0(m)=1+c_1m+\dots+c_pm^p$. Домножим это
равенство на $n$, тогда почти все слагаемые поубиваются ($mn \equiv 0 \pmod{k}$), и останется неверное
равенство $0=n$. Противоречие.
\end{proof}

\subsection{Замкнутый класс без базиса}

\begin{stm}
Если $k \ge 3$, то в $P_k$ существует замкнутый класс, не имеющий базиса.
\end{stm}

\begin{proof}
Рассмотрим класс
функций вида $\ph_i(\X{1}{i})$, равных 1 на наборах из одних двоек, и 0 в  противном случае. Он,
очевидно, замкнут, поскольку при подстановке функции $\ph_i$ в функцию $\ph_j$ мы получаем нуль.
Действительно, функция $\ph_i$ никогда не принимает значение 2, стало быть, аргументы $\ph_j$\т не
есть набор сплошь из двоек. Отсюда следует, что из функции с меньшим номером нельзя получить функцию с
большим номером. Значит, с одной стороны, базис должен содержать все функции $\ph_i$, а с другой стороны,
отождествлением переменных можно из функции с большим номером получить все функции с меньшими номерами.
Значит, этот класс базиса не имеет.
\end{proof}

\subsection{Класс, имеющий счётный базис}
Рассмотрим множество функций вида $\psi_i(\X{1}{i})$, равных 1, если среди аргументов ровно 1 единица,  а
остальные\т двойки, и равных 0 во всех остальных случаях. Оно, очевидно, замкнуто.

\begin{stm}
Любая из функций $\psi_i$ не выражается через остальные.
\end{stm}

\begin{proof}
Докажем, что $\psi_i$ не может получиться из $\psi_j$ путём
отождествления переменных. В самом деле, положим отождествлённую переменную равной 1, остальные\т 2. Тогда
функция с меньшим числом переменных будет равна 1, а другая\т 0, т.к. среди её аргументов более одной
единицы. Теперь докажем, что одна функция не получается из другой при помощи подстановки. Рассмотрим два
случая. \pt{1} Среди аргументов функции $\psi_i$ есть ровно 1 подформула на $s$-м месте. Тогда
подставим набор с единицей на любом месте, кроме $s$-го. Тогда функция с подформулой примет значение 0
(аналогично случаю отождествления), а без подформулы\т 1. Значит, эти две функции не равны. \pt{2}
Среди аргументов есть хотя бы 2 подформулы. Подставим любой набор вида $(2 \sco 2,1,2 \sco 2)$. Очевидно,
функция с подформулами на нём обнулится, а без подформул\т нет.
\end{proof}

Отсюда следует, что любое подмножество данного класса замкнуто, и каждая функция, в свою
очередь, является базисной. Значит, в $P_k$ континуум замкнутых классов, ибо их столько же, сколько
бесконечных последовательностей из нулей и единиц. Действительно, можно установить биекцию между любым
подмножеством этого класса и множеством последовательностей: на $i$-том месте в последовательности ставим 0,
если $\psi_i$ не лежит в данном подмножестве, и 1 в противном случае. Каждая последовательность\т бесконечная двоичная дробь без разделительной точки. Значит, классов столько же, сколько и всех
действительных чисел.

\section{Схемы из функциональных элементов}

\subsection{Графы}

\begin{df}
\emph{Граф}\т это упорядоченная пара $(V,E)$, где $V$\т не более чем счётное множество, элементы которого
называются \emph{вершинами}, а $E \subseteq V \times V$\т множество пар вершин $\hc{(v_i,v_j)}$, называемых рёбрами
графа. \emph{Концами} ребра называются элементы пары, образующей ребро. Если концы совпадают, то ребро называется
\emph{петлёй}. Вершина называется \emph{изолированной}, если она не является концом никакого ребра. Вершина называется
\emph{концевой}, если она является концом ровно одного ребра.
\end{df}

\begin{df}
\emph{Подграф} графа $(V,E)$\т такой граф $(W,F)$, что $W \subseteq V$ и $F \subseteq W \times W$.
\end{df}

\begin{df}
\emph{Геометрическая реализация графа.} Рассмотрим $\mathbb{R}^n$. Отметим в нём столько точек, сколько вершин
у нашего графа. Каждому ребру поставим в
соответствие кривую, соединяющую концы этого ребра. Эту кривую мы тоже будем называть ребром. То, что
получится, и будет геометрической реализацией. Геометрическая реализация называется правильной, если у рёбер
нет общих точек, кроме, быть может, вершин.
\end{df}

\begin{stm}
В $\R^3$ для любого графа имеется правильная геометрическая реализация.
\end{stm}

\begin{proof}
Сперва расставим вершины произвольно. Очевидно, путём малых шевелений можно
сделать так, что никакие 4 не будут лежать в одной плоскости. Теперь для любых трёх вершин есть своя
плоскость, а плоский граф из трёх вершин, очевидно, допускает правильную реализацию.
\end{proof}

\begin{df}
\emph{Путь}\т конечная
последовательность рёбер графа $(v_{i_1},v_{i_2}),(v_{i_2},v_{i_3}) \sco (v_{i_{n-1}},v_{i_n})$. Говорят, что
путь соединяет вершины $v_{i_1}$ и $v_{i_n}$. Простой путь (цепь)\т путь, все вершины которого различны.
\emph{Цикл}\т путь, у которого $v_{i_1}=v_{i_n}$. \emph{Простой} цикл\т цикл, у которого все рёбра и все вершины,
кроме концов, различны. Граф называется \emph{связным}, если любые 2 его вершины можно соединить путём.
\emph{Деревом} называется связный граф без простых циклов.
\end{df}

\begin{stm}
Из каждого конечного связного графа можно выделить подграф,
содержащий все вершины исходного графа и являющийся деревом.
\end{stm}

\begin{proof}
Если в графе есть простой цикл, то можно
убрать из цикла одно ребро, не нарушив связности. Будем убирать рёбра, пока простых циклов не станет.
\end{proof}

\begin{df}
Назовём граф \emph{ориентированным}, если каждому его ребру приписано направление.
\end{df}

\begin{df}
\emph{Ориентированный цикл}\т цикл, в котором все рёбра направлены в одну сторону, \те конечная
последовательность ориентированных рёбер $\br{\overrightarrow{v_{i},v_{i+1}}}$, где первая
вершина совпадает с последней.
\end{df}

\begin{lemma}
В любом конечном ориентированном графе без ориентированных циклов есть вершина, из которой рёбра не выходят.
\end{lemma}

\begin{proof}
От противного: выберем любую вершину и, исходя из неё, будем двигаться по рёбрам в направлении,
приписанном данному ребру. Если из каждой вершины выходит хотя бы одно ребро, то рано или поздно мы
вернёмся туда, где уже были, поскольку граф конечен. Но это будет ориентированный цикл. Противоречие.
\end{proof}

\begin{theorem}
В любом конечном ориентированном графе без ориентированных циклов можно занумеровать вершины первыми
натуральными числами так, что каждое ребро будет направлено от вершины с меньшим номером в вершину с большим
номером.
\end{theorem}

\begin{proof}
Докажем индукцией по числу вершин $p$. При $p=1$ утверждение очевидно. Пусть $p>1$.
Предположим, что это верно для всех графов с числом вершин, меньшим $p$. Рассмотрим граф с $p$ вершинами. По
лемме у него есть вершина, из которой рёбра не выходят. Уберём из графа эту вершину и все входящие в неё
рёбра, получим граф с числом вершин, меньшим $p$. По предположению индукции такой граф допускает искомую
нумерацию вершин числами $1,2 \sco p-1$. Тогда присвоим выкинутой вершине номер $p$.
\end{proof}

\subsection{Схемы из функциональных элементов}
\vskip-12pt
\rightpicture{pictures.10}
\begin{df}
\hangindent=-28mm
\hangafter=-5
\emph{Схема из функциональных элементов} (СФЭ)\т это конечный ориентированный граф без ориентированных
циклов, в каждую вершину которого входит не более 2 рёбер. При этом каждой вершине приписывается символ:
переменная $x_i$, если в эту вершину рёбра не входят; отрицание, если в вершину входит одно ребро; конъюнкция
или дизъюнкция, если в вершину входит 2 ребра. Некоторым вершинам приписывается~$*$.
\emph{Элементами} схемы называются вершины, помеченные логическими операциями.
\end{df}

Занумеруем вершины графа согласно предыдущей
теореме. Каждой вершине СФЭ можно сопоставить некоторую булеву функцию по следующему индуктивному правилу.
Пусть всем вершинам с номерами меньше $n$ уже сопоставлены функции. Возьмём вершину с номером $n$. Если в неё
не входит ни одного ребра, то ей приписана переменная, которую мы как функцию и поставим ей в соответствие.
Если в вершину входит одно ребро, то в ней записано отрицание, и мы припишем этой вершине отрицание функции
той вершины, из которой в данную вершину приходит ребро. Если входит два ребра, то в этой вершине будет
конъюнкция или дизъюнкция функций тех вершин, из которых приходят эти рёбра. Видно, что такое определение
корректно.

\begin{df}
Функции, отвечающие вершинам, отмеченным $*$, называются \emph{реализуемыми} данной СФЭ.
\end{df}

\begin{ex}
Приведённая выше схема реализует функцию $(x_1 \vee x_2) \& (\ol{x_1 \& x_2})=x_1 \oplus x_2$.
\end{ex}

Существует физическая интерпретация СФЭ, в которой они рассматриваются как математические модели
соответствующих реальных электронных схем: если на вход подаётся набор значений (наличие тока соответствует
единице, отсутствие\т нулю), то на выходе получается значение функции на этом наборе.

\begin{df}
\emph{Сложностью схемы} $S$ называется число элементов $L(S)$ в ней. \emph{Сложностью функции} $f$ называется минимальная
сложность схемы для $f$. \emph{Функция Шеннона} $L(n)$ выражает максимальную сложность функций от $n$ переменных.
\end{df}

Построим СФЭ, реализующую функцию $f=\XSig{n}$. Перегруппируем множители, собрав в одном месте переменные  с
нулевыми степенями. Тогда, перенумеровав переменные и применив правило Де Моргана, функцию можно переписать в
виде $f=(x_1x_2\dots x_k)(\ol{x_{k+1} \vee x_{k+2} \vee \dots \vee x_n})$. Заметим, что в этой формуле не
более $n$ операций. Значит, сложность схемы данной функции не превосходит $n$. Теперь построить схему легко.

Теперь мы сможем ограничить сложность любой функции $f$ сверху. Построим СДНФ для этой функции. В ней может
быть не более $2^n$ дизъюнкций выражений вида $\XSig{n}$. Так как сложность каждого дизъюнкта мы уже оценили
числом $n$, то сложность всей схемы не превосходит $n \cdot 2^n$. Для функций, тождественно равных нулю,
можно использовать формулу $f=x_1 \& \nx_1$. При этом мы предполагаем, что $f$\т функция по крайней мере от
одной переменной. Схема будет содержать 2 элемента, значит, её сложность $L(f)=2\le n \cdot 2^n$. Итак,
сложность любой функции $L(n) \le n \cdot 2^n$.

\begin{note}
На самом деле можно сэкономить ещё в 2 раза.
Действительно, если среди значений функции по всем наборам больше нулей, чем единиц, то выгодно использовать
СДНФ, а если наоборот, то СКНФ (конъюнктивную форму, \те конъюнкцию дизъюнкций).
\end{note}

\subsection{Контактные схемы}

\begin{df}
\emph{Контактная схема} (КС)\т это конечный граф, в котором каждому ребру приписана переменная либо её
отрицание и отмечены некоторые вершины\т полюса.
\emph{Функция проводимости} полюсов $a$ и $b$ некоторой контактной схемы\т функция
$f_{a,b}$, которая равна 1, если $a=b$; равна 0, если в КС нет цепей, соединяющих $a$ и $b$; в остальных
случаях $f$ равна дизъюнкции всех цепей, соединяющих $a$ и $b$, а каждая цепь равна конъюнкции всех своих рёбер.
Сложностью КС называют число рёбер в ней.
\end{df}

\vskip-10pt
\rightpicture{pictures.20}
\begin{ex}
\hangindent=-50mm
\hangafter=-3
Здесь $f_{a,b}=x_1x_2x_3 \vee x_1 \, \nx_2 \, \nx_3 \vee \nx_1 \, x_2 \nx_3 \vee
\nx_1\, \nx_2 \, x_3 = x_1 \oplus x_2 \oplus x_3$. Остальные цепи, соединяющие $a$ и $b$, равны нулю, поскольку
содержат какую-нибудь переменную вместе с её отрицанием.
\end{ex}

\hangindent=-50mm
\hangafter=-1
Если граф неориентированный, то $f_{a,b}=f_{b,a}$.

\hangindent=-50mm
\hangafter=-2
Для каждой контактной схемы составим \emph{матрицу функции проводимости}, в которую поместим значения функции
проводимости на всевозможных полюсах. В примере, приведённом выше, эта матрица выглядела так:
\ctab{|c|c|c|}{\hline
    & $a$ & $b$                         \\ \hline
$a$ &  1  & $x_1 \oplus x_2 \oplus x_3$ \\ \hline $b$ & $x_1 \oplus x_2 \oplus x_3$ &
1 \\ \hline}

Пусть число полюсов равно $k$. Выясним, какие условия надо наложить на произвольную матрицу $k
\times k$,  состоящую из функций, чтобы существовала КС с такой матрицей проводимости. Для любых трёх полюсов
$i,j,k$ необходимо, чтобы $f_{i,k}$ принимала значение 1 на всех наборах, на которых $f_{i,j}$ и $f_{j,k}$
одновременно принимают значение 1. Это означает, что $f_{i,k} \geqslant f_{i,j} f_{j,k}$. Для
неориентированных КС матрица должна быть симметрична относительно главной диагонали. На диагонали матрицы
должны стоять единицы (по определению функции проводимости). Можно доказать, что этих трёх требований
достаточно для существования КС с такой матрицей проводимости.

\vskip-10pt
\rightpicture{pictures.30}
\hangindent=-77mm
\hangafter=-7
Оценим сверху сложность функции $f$ от $n$ переменных. Воспользуемся правилом построения СДНФ: выберем все
наборы $(\si_1 \sco \si_n )$, на которых функция равна 1. Их число $s$ не превосходит $2^n$. Для каждого набора
построим цепь, соединяющую два полюса схемы и реализующую функцию $\XSig{n}$ (на рисунке $a^{ij}_k := x^{\si_{ij}}_k$). В каждой такой цепи ровно $n$
рёбер. Отсюда следует оценка $L(n) \le n \cdot 2^n$.

\hangindent=-77mm
\hangafter=-2
С точки зрения физики, КС\т математические модели схем из электромагнитных реле.

\subsection{Метод каскадов для построения КС и СФЭ}

Пусть дана функция $f(\X{1}{n})$. Разложим её по переменной $x_1$ и введём обозначения:
$$f(\X{1}{n})=\nx_1 f(0,\X{2}{n}) \vee x_1 f(1,\X{2}{n}).$$
$$G_0 := \hc{f}, \quad
g_{10}(\X{2}{n}) := f(0,\X{2}{n}), \quad
g_{11}(\X{2}{n}) := f(1,\X{2}{n}),\quad
G_1 := \hc{g_{10},g_{11}}.$$

\vskip-10pt
\rightpicture{pictures.40}
\hangindent=-50mm
\hangafter=-4
Далее поступаем с функциями из
$G_1$ так же, как и с $f$, получаем множество функций $G_2$, и так далее, \те на $i$-том шаге функции из
$G_{i-1}$ раскладываем по переменной $x_i$ и полученные функции от $n-i$ переменных помещаем в $G_i$, пока не
достигнем $G_{n-1} \subseteq P_2(1)$. Функции множества $G_{n-1}$ реализуются просто (см. рисунок).
Теперь мы сможем построить любую функцию из $G_i$, если мы уже построили все функции из $G_{i+1}$: добавим  к
нужным функциям из $G_{i+1}$ рёбра $x_{i+1}$ и $\ol{x}_{i+1}$, руководствуясь разложением данной функции $g$
из $G_i$. Так будем продолжать, пока не дойдём до $G_0=\hc{f}$.

\vskip-10pt
\rightpicture{pictures.50}
\hangindent=-50mm
\hangafter=-4
Метод каскадов можно применить и для построения СФЭ. Пусть на очередном шаге для некоторой функции $g_{ij}$ из множества $G_i$ имеется
разложение $g_{ij}\bw=\ol{x}_{i+1} g_{ij}(0,\X{i+2}{n}) \bw\vee x_{i+1}g_{ij}(1,\X{i+2}{n})$.
Тогда навешиваем ФЭ на уже построенные функции $g_{ij}(0,\X{i+2}{n}) \in G_{i+1}$ и $g_{ij}(1,\X{i+2}{n}) \in G_{i+1}$,
как показано на рисунке.

\begin{ex}
\hangindent=-50mm
\hangafter=-4
Рассмотрим построение КС методом каскадов для функции $f=\XOP{1}{n}$. Разлагая $f$ по $x_1$,  получим
$f=\nx_1(0\bw\oplus \XOP{2}{n}) \vee x_1 (1 \bw\oplus \XOP{2}{n})$, тогда $G_1= \hc{\XOP{2}{n}, 1 \bw\oplus
\XOP{2}{n}}$. Разлагая функции из $G_1$ по $x_2$, получаем $\XOP{2}{n}=\nx_2(0\oplus \XOP{3}{n}) \vee x_2(1
\bw\oplus \XOP{3}{n})$ и $1\bw\oplus\XOP{2}{n}=x_2(0 \bw\oplus\XOP{3}{n}) \vee \nx_2(1\oplus \XOP{3}{n})$. Тогда
$G_2=\hc{\XOP{3}{n}, 1\bw\oplus \XOP{3}{n}}$.
\vskip-5pt
\rightpicture{pictures.60}
\hangindent=-105mm
\hangafter=-4
Ясно, что $|G_i|=2$, поскольку каждое множество будет содержать одну однородную и одну неоднородную линейную
функцию. Cложность схемы (см. рисунок справа) равна $4n-4$, и можно доказать, что она минимальна.
\end{ex}

\subsection{Оценка сложности схем при построении методом каскадов}

Положим $A_s := |G_s|$. Из построения множеств $G_i$ следует, что $A_0=1 \, A_i \le 2^i$.  С
другой стороны, $A_i \le 2^{2^{n-i}}$, поскольку $G_i \subseteq P_2(n-i)$. Обе оценки хороши: первая
полезна, когда $i$ близко к 0, вторая\т когда $i$ близко к $n$. Значит, при построении число функций сначала
растёт, а затем будет быстро уменьшаться\т в этом и состоит экономность метода каскадов. На каждом этапе
построения мы добавляем не более 2 рёбер. Следовательно, для контактных схем $L(S) \le
2+2\suml{i=0}{n-2}A_i$.

Для СФЭ на $i$-том шаге можно обойтись $1+3A_i$ функциональными элементами\т одним для отрицания  переменной
и тремя (2 конъюнкции и 1 дизъюнкция) для каждой новой функции. Значит, справедлива оценка

\eqn{L(S) \le \suml{i=0}{n-2}(1+3A_i)+3 = n+2+3\suml{i=0}{n-2}A_i.}

\begin{note}
Метод каскадов не всегда даёт схему минимальной сложности. Для функции $f=\XOP{1}{n}$ он даёт СФЭ
сложности $7n-C$, в то время как для неё имеется схема сложности $4n-4$.
\end{note}

Приступим к оценке суммы $\suml{i=0}{n-2}A_i$. Учитывая оценки для чисел $A_i$, разобьём нашу сумму на две части,
учитывая степень влияния каждой из оценок. Пусть $k$\т «точка разбиения». Представим нашу сумму в виде
$$\suml{i=0}{n-2}A_i=\suml{i=0}{n-k}A_i+\suml{i=n-k+1}{n-2}A_i \le \suml{i=0}{n-k}2^i + \suml{i=n-k+1}{n-2}2^{2^{n-i}}
<2^{n-k+1}+(2^{2^{k-1}} + 2^{2^{k-2}} + \dots) \lesssim 2^{n-k+1}+ 2^{2^{k-1}}.$$ Здесь первое слагаемое\т сумма геометрической прогрессии $\hc{2^i}_{i=0}^{n-k}$, а знак $\lesssim$ означает <<асимптотически меньше>>,
\те отброшенная часть $2^{2^{k-2}} + 2^{2^{k-3}}+ \dots$ бесконечно мала по сравнению с оставленной при $k
\ra \infty$. Положим $\ph(k) := 2^{n-k+1}+ 2^{2^{k-1}}$. Строго говоря, для нахождения минимума
этой функции следовало бы найти нуль её производной, а затем в качестве $k$ выбрать ближайшее к этому корню
целое число. Уравнение $\ph'(k)=0$ легко преобразуется к виду $2^{k-1}+2k=n + 2 - \log_2\ln 2$. Однако в
явном виде решение указать нельзя, поэтому мы для оценки воспользуемся точкой деления $k=\bigl[\log_2
n\bigr]$. Тогда имеем $k > \log_2 n - 1$, следовательно $\ph(k) \le 2^{n+2-\log_2 n}+ 2^{2^{\log_2
n-1}} \le 4 \frac{2^n}{n} + 2^{\frac{n}{2}}$. Поскольку $2^{\frac{n}{2}}=o\Bigl(\frac{2^n}{n}\Bigr)$ при $n \ra \infty$, его можно отбросить. Значит, для КС справедлива оценка $8\frac{2^n}{n}$, а для СФЭ\т $12\frac{2^n}{n}$.
Можно показать, что $L(S) \sim \frac{2^n}{n}$ и для СФЭ, и для КС. Здесь мы не будем этого доказывать, но убедимся
в её неулучшаемости.

\begin{theorem}
Оценку $\frac{2^n}{n}$ нельзя улучшить: при всяком $n$ найдётся функция со сложностью, близкой к~$\frac{2^n}{n}$.
\end{theorem}
\begin{proof}
Введём обозначения: $N(n,h)$\т число функций $n$ переменных сложности не более $h$,
$E(n,h)$\т число функций сложности ровно $h$, и $S(n,h)$\т число всех схем сложности $h$.

Докажем, что $S(n,h) \le 3^h(h+n)^{2h+1}$ для СФЭ. В самом деле, у нас имеется не более $2h$ входов и
$h+n$ выходов, каждый вход может быть присоединён к любому выходу ($(h+n)^{2h}$ вариантов),  каждый из $h$
элементов может быть либо отрицанием, либо конъюнкцией, либо дизъюнкцией ($3^h$ возможностей), кроме того,
один выход помечен $*$\т ещё $h+n$ возможностей. Поэтому оценка для $S(n,h)$ справедлива.

Ясно, что $N(n,h)=E(n,h) \le S(n,h)$. Действительно, равенство следует из того, что любую схему
сложности меньше $h$ можно дополнить ничего не делающими элементами до схемы сложности $h$, неравенство же
следует из того, что различных схем заведомо больше, чем различных функций: одна функция может быть
реализована двумя разными схемами, но не наоборот.

Понятно, что если $N(n,h_0) < 2^{2^n}=p_2(n)$ для некоторого $h_0$, то найдётся функция со сложностью больше,
чем $h_0$. Логарифмируя данное неравенство, получаем: $\log_2\frac{N(n,h_0)}{p_2(n)}=\log_2 N(n,h_0)-2^n<0$.
Нужно убедиться в существовании некоторого $h_0$, для которого это неравенство будет справедливо при
достаточно больших $n$. Возьмём $h_0=\frac{1}{3}\cdot \frac{2^n}{n}$. Имеем
\eqn{\log_2 N(n,h_0)-2^n \le \log_2 S(n, h_0) - 2^n \le h_0 \log_2 3 + (2h_0+1)\log_2(h_0+n) - 2^n.}
При достаточно больших $n$ имеем $\log_2(h_0+n) < n$, поэтому
\eqn{\log_2 N(n,h_0)-2^n < \frac{\log_2 3}{3}\cdot \frac{2^n}{n} + (\frac{2}{3}\cdot \frac{2^n}{n}+1)n - 2^n=
\frac{\log_2 3}{3} \cdot \frac{2^n}{n} + n - \frac{1}{3}\cdot 2^n.}
Видно, что при $n \ra \infty$ последнее выражение стремится к $-\infty$, и тем самым неравенство
доказано. Таким образом, мы показали, что $L(n) \gtrsim \frac{1}{3} \cdot \frac{2^n}{n}$. Следовательно,
оценку улучшить не удастся.
\end{proof}

Для КС можно показать, что $S(n,h_0)\le (2n)^h(2h)^{2h}$. Действительно, для каждого контакта есть $2n$
возможностей\т $x_i$ и $\ol{x}_i$, способов их соединения\т не более $(2h)^{2h}$, потому что  каждый из
$2h$ концов рёбер можно соединить с каждым. Далее поступаем так же, как и в предыдущем утверждении про СФЭ.

\section{Автоматы}

\subsection{Детерминированные функции}

\begin{df}
\emph{Алфавит}\т произвольное конечное множество. Его элементы называются \emph{буквами}.
\end{df}

Рассмотрим два алфавита $A=\hc{a_1,a_2 \sco a_n}$, $B=\hc{b_1,b_2 \sco b_m}$ и функции
вида $f\cln A^\infty \ra B^\infty$, \те функции, преобразующие бесконечные последовательности букв $A$ в
бесконечные последовательности букв $B$.

\begin{ex}
Пусть $f$ переводит последовательность, состоящую сплошь из нулей, в себя, а все остальные\т в
последовательность, состоящую сплошь из единиц. Для такой функции существует последовательность\т состоящая
лишь из нулей, для которой невозможно определить её образ, зная лишь конечное число членов. Это причиняет
неудобства при вычислении, поэтому введём понятие детерминированности.
\end{ex}

\begin{df}
Функция $f\cln A^\infty \ra B^\infty$ называется \emph{детерминированной}, если $b(t)$ однозначно определяется
первыми $t$ членами входной последовательности $a(1),a(2) \sco a(t)$.
\end{df}

\begin{ex} Детерминированными функциями являются:
\begin{itemize}
\item Функция $\br{0 \sco 0,\underset{t}{1},? \sco ?,\dots} \mapsto \br{0 \sco 0,\underset{t}{1},1 \sco 1,\dots}$. Здесь «?»\т любой символ.
\item Функция чётности $b(t)=a(1)\sop a(t)$;
\item Функция единичной задержки $\br{a(1),a(2) \sco a(t),\dots} \mapsto \br{0,a(1),a(2) \sco a(t-1),\dots}$;
\item Функция $b(t)=\case{1, & t=2^m; \\ 0, & t\neq 2^m.}$
\end{itemize}
\end{ex}

Детерминированные функции можно задавать на бесконечных деревьях. Рассмотрим бинарное дерево, \те такое,
что из каждой вершины выходит 2 ребра, и во все вершины, кроме одной (начальной), входит одно ребро. В
начальную вершину рёбра не входят. Каждой бесконечной двоичной последовательности поставим в соответствие
определённый путь на дереве: движение начинается из начальной вершины, и если $a(i)=0$, то идём по левой
ветке, а если $a(i)=1$, то по правой. При этом очередному звену пути приписываем значение $b(i)$. Легко
видеть, что такое соответствие осуществляет биекцию между деревьями и детерминированными функциями.

\vskip-7pt
\rightpicture{pictures.70}
\begin{ex}
\hangindent=-100mm
\hangafter=-5
Эти два дерева иллюстрируют первые два примера детерминированных функций, приведённых выше.
\end{ex}

\vskip 20pt

\subsection{Автоматы}

\begin{df}
\emph{Ограниченно детерминированные} функции \emph{(конечные автоматы)}\т детерминированные функции, деревья
которых содержат лишь конечное число различных поддеревьев.
\end{df}

Пронумеруем различные поддеревья. Номера будем писать в начальных вершинах поддеревьев.

\rightpicture{pictures.80}
\begin{ex}
\hangindent=-60mm
\hangafter=-4
Рассмотрим снова функцию чётности. Её дерево содержит только 2 вида поддеревьев.
Эту диаграмму надо понимать так: если мы находимся в дереве №1 и на входе 0, то выход\т 0 и мы остаёмся  в
дереве №1, а если на входе 1, то выход\т 1 и мы переходим в дерево №0. Аналогично для дерева №0.
\end{ex}

В общем случае, если речь идёт о конечно детерминированных функциях, можно утверждать, что достаточно знание
конечного числа конечных фрагментов дерева, чтобы найти образ любой последовательности.

\begin{df}
Номера поддеревьев называются \emph{состояниями} автомата.
\end{df}

Фрагменты дерева могут задаваться \emph{диаграммами переходов (диаграммами Мура)}. Они представляют собой
ориентированные графы, вершины которых соответствуют состояниям,
а каждому ребру приписывается пара символов, первая компонента которой соответствует входу, а вторая\т выходу.
Направление ребра соответствует переходу из одного состояния в другое.

\rightpicture{pictures.90}
\hangindent=-60mm
\hangafter=-1
\begin{ex}
Диаграмма Мура для функции чётности (см. рисунок).
\end{ex}

\hangindent=-60mm
\hangafter=-2
Автомат можно задавать \emph{функцией перехода} $q(t+1)=G\br{a(t),q(t)}$ и \emph{функцией выхода} $b(t)=F\br{a(t),q(t)}$.
Здесь $q(t)$\т состояние в момент $t$. Удобно считать $q(1)=0$. Эти три уравнения называются \emph{уравнениями автомата}.

\rightpicture{pictures.100}
\begin{ex}
\hangindent=-60mm
\hangafter=-3
Найдём уравнения автомата единичной задержки, \те функции с выходом
$b(1)=0$, $b(t)=a(t-1)$, $t>1$. Построим диаграмму Мура (см. рисунок).
По ней видно, что $q(t+1)\bw=a(t)$, а $b(t)\bw=q(t)$. При этом $q(1)\bw=0$.
\end{ex}

\rightfloatingbox{\tab{|c|c|c|}{
\hline $a$ & $q$ & $F(a,q), \, G(a,q)$ \\
\hline 0   & 0   & $(0,0)$ \\
\hline 0   & 1   & $(1,0)$ \\
\hline 1   & 0   & $(0,1)$ \\
\hline 1   & 1   & $(1,1)$ \\ \hline}}

\vskip-10pt
\hangindent=-45mm
\hangafter=-2
Можно также задавать диаграммы функций таблицами. Например, функция единичной задержки задаётся
следующей таблицей:

\begin{theorem}
\hangindent=-45mm
\hangafter=-2
Любой автомат можно реализовать СФЭ, используя элементы 4 видов: конъюнкцию, дизъюнкцию,
отрицание и функцию единичной задержки.
\end{theorem}
\begin{proof}
\hangindent=-45mm
\hangafter=-2
Пусть даны два алфавита $A$ и $B$. Положим $n := \bigl\lceil\log_2 |A|\bigr\rceil$,
$m := \bigl\lceil\log_2 |B|\bigr\rceil$. Занумеруем буквы $A$ и $B$
двоичными последовательностями длины $n$ и $m$ соответственно. Состояния автомата $q_0 \sco  q_{\lambda-1}$
также занумеруем двоичными последовательностями длины $l \bw{:=} \bigl\lceil\log_2 \lambda \bigr\rceil$,
причём $q_0$ соответствует $(0 \sco 0)$. Введём новые функции перехода и выхода, определённые уже на наборах
из 0 и 1:
$$\case{\br{\beta_1(t) \sco \beta_m(t)} = \wt{F}\br{\al_1(t) \sco \al_n(t),\omega_1(t) \sco \omega_l(t)}\\
\br{\omega_1(t+1) \sco \omega_l(t+1)}=\wt{G}\br{\al_1(t) \sco \al_n(t),\omega_1(t) \sco \omega_l(t)}}$$

\rightpicture{pictures.110} % device
\hangindent=-45mm
\hangafter=-3
Каждая из компонент векторов $\wt{\beta}$ и
$\wt{\omega}$ реализуется некоторой булевой функцией  (вообще говоря, не всюду определённой).
Построим СФЭ, совместно реализующую все эти функции (обозначим их через $f_1 \sco f_m$ и
$\sG{1}{l}$).

\hangindent=-45mm \hangafter=-2 Соединим выходы $\sG{1}{l}$ через элементы единичной задержки (они
показаны на рисунке прямоугольниками) с входами $\om_1\dots \om_l$. Очевидно, что такая схема будет
работать согласно приведённым выше уравнениям автомата (при условии, что элементы единичной
задержки в первый момент времени выдают нули).
\end{proof}

Обратное также верно: любая СФЭ типа той, что была рассмотрена выше, моделирует некоторый автомат.

\begin{note}
Если разрешить использовать в схеме вместо $\BStd$ любые автоматные функции, но запретить
ориентированные циклы, то не существует такого конечного набора автоматных функций, схемой из которых можно
было бы реализовать любой автомат. Иными словами, не существует конечной полной системы автоматов.
\end{note}

\section{Логика. Исчисления и предикаты}

\subsection{Исчисление высказываний (ИВ)}

\begin{df}
\emph{Высказывание}\т повествовательное сообщение, которое в силу своего смысла может быть либо истинным,
либо ложным.
\end{df}

\begin{ex}
«23.04.2001\т понедельник»\т истинное высказывание, «23.04.2001\т вторник»\т ложное
высказывание. «Среда ли 23.04.2001?»\т не высказывание.
\end{ex}

Истинность высказывания будем обозначать 1, ложность\т 0. Встречаются обозначения И, Л (начальные буквы
соответствующих слов), иногда $\top$ и $\bot$. Будем рассматривать 4 булевы функции $\hc{\neg \, \& \, \vee
\, \ra}$ и будем строить над ними тождественно истинные формулы, \те принимающие значение 1 при любых
значениях аргументов.

Рассмотрим систему аксиом ИВ:
\begin{nums}{-3}
\item Аксиомы, содержащие только импликацию:
  \begin{nums}{-1}
  \item $A \ra (B \ra A)$
  \item $\br{A \ra (B \ra C)} \ra \br{(A \ra B) \ra (A \ra C)}$
  \end{nums}
\item Аксиомы, содержащие конъюнкцию:
  \begin{nums}{-1}
  \item $(A \& B) \ra A$
  \item $(A \& B) \ra B$
  \item $\bs{A \ra B} \ra \bs{\br{A \ra C} \ra \br{A \ra (B \& C)}}$
  \end{nums}
\item Аксиомы, содержащие дизъюнкцию:
  \begin{nums}{-1}
  \item $A \ra (A \vee B)$
  \item $B \ra (A \vee B)$
  \item $\bs{A \ra C} \ra \bs{\br{B \ra C} \ra \br{(A \vee B) \ra C}}$
  \end{nums}
\item Аксиомы, содержащие отрицание:
  \begin{nums}{-1}
  \item $(A \ra B) \ra (\ol{B} \ra \ol{A})$
  \item $A \ra \ol{\ol A}$
  \item $\ol{\ol A} \ra A$
  \end{nums}
\end{nums}

Сформулируем правило вывода, вытекающее из свойств импликации: $A \equiv 1$, $(A \ra B) \equiv 1$. Тогда $B
\equiv 1$. Оно иногда записывается в виде $\frac{A \ra B, A}{B}$.

\begin{df}
\emph{Вывод}\т конечная последовательность
формул $\hc{F_1 \sco F_s}$, причём любая её формула есть  либо аксиома, либо получается по правилу вывода из
предыдущих формул этой последовательности. Формула называется выводимой, если существует вывод, содержащий
эту формулу.
\end{df}

\begin{theorem}
Любая выводимая формула тождественно равна 1.
\end{theorem}
\begin{proof}
Истинность аксиом легко проверяется путём полного
перебора всех возможных наборов значений  переменных, в них входящих, что предлагается сделать читателю в
качестве полезного упражнения. Теперь утверждение теоремы вытекает из правила вывода.
\end{proof}

\begin{ex}
Выведем формулу $A \ra A$. По \textbf{1.б} имеем
$$\Br{A \ra \br{(A \ra A ) \ra A}} \ra \Br{\br{A \ra (A \ra A)} \ra
(A \ra A)}.$$
Эта формула имеет вид $P \ra Q$, где $P=A \ra \br{(A \ra A ) \ra A}$. Но $P$ истинна, т.к. она
получается из \textbf{1.a}  подстановкой $B=A \ra A$. Значит, можно вывести $Q=\br{A \ra (A \ra A)} \ra (A \ra
A)$. Аналогично, она имеет вид $R \ra X$, где $R = A \ra (A \ra A)$, а $X=A \ra A$. Подставим в \textbf{1.a}
$B=A$, получим, что $R$ истинна. Итак, истинны $R$ и $R \ra X$. Следовательно, $X=A \ra A$ выводимо.
\end{ex}

\begin{theorem}
Любая тождественно истинная формула выводима, \те наш набор аксиом полон.
\end{theorem}
\begin{proof}
Мы не будем доказывать эту теорему, поскольку доказательство очень длинное, но не
очень содержательное.  Идея доказательства состоит в том, что тождественно истинная
формула приводится к СДНФ и переписывается в терминах этой системы аксиом,
откуда следует её выводимость.
\end{proof}

\begin{df}
\emph{Исчисление}\т конечный набор аксиом $A_1 \sco  A_r$ и правил вывода $R_1 \sco R_q$, каждое  из которых
устроено как $R_i=\frac{S_i^1 \sco S_i^{t_i}}{S_i}$. Исчисление \emph{непротиворечиво}, если не существует выводимой
формулы, для которой выводимо и её отрицание.
\end{df}

\begin{ex}
ИВ непротиворечиво, \тк в нём формула выводима тогда и только тогда, когда она тождественно
истинна. А отрицание тождественно истинной формулы тождественно ложно, значит, невыводимо.
\end{ex}

\begin{df}
Система аксиом называется \emph{независимой}, если в ней нет аксиомы, выводимой из остальных.
\end{df}

\subsection{Предикаты}

\begin{df}
$n$-местный \emph{предикат}\т функция вида $P: \Mc^n \ra \Omega$, где $\Mc$\т некоторое множество,
$\Om$\т множество высказываний. Одноместные предикаты иногда называются \emph{свойствами}. При $n > 1$  предикаты иногда
называются \emph{отношениями}.
\end{df}

\begin{ex}
$P(x)=$ «$x$\т чётное число»\т предикат, определённый, скажем, на множестве $\mathbb{N}$.
\end{ex}

Из предикатов можно составлять формулы, используя наши 4 булевы функции. При этом также получаются предикаты.

\begin{ex}
$P(x,y,z,w)=Q(x) \& R(y) \vee S(z,w)$.
\end{ex}

\begin{df}
\emph{Полная система предикатов} на конечном множестве $\Mc$\т такая система, что любой предикат  над $\Mc$
выражается через предикаты этой системы.
\end{df}

Очевидно, одноместных предикатов на конечном множестве $\Mc$ имеется $2^{|\Mc|}$, поскольку  одноместный
предикат задаёт некоторое подмножество множества $\Mc$. Именно поэтому одноместные предикаты называют
свойствами.

\begin{theorem}
Система предикатов $\Pc=\hc{P_1(x) \sco P_s(x)}$\т полная $\Lra \fa \; a,b \in \Mc, a\neq b$,
найдётся предикат $P_i \in \Pc$, такой, что $P_i(a) \neq P_i(b)$.
\end{theorem}

\begin{proof}
$\Ra$ Докажем от противного.
Предположим, все предикаты из $\Pc$ принимают равные значения на $a$ и $b$. Тогда любая формула над этой
системой обладает тем же свойством, значит, нельзя получить, например, предикат, который равен 1 на $a$ и 0 в
остальных точках (в том числе $b$). Противоречие.

$\Leftarrow$ Построим формулу для любого предиката над $\Pc$. Пусть $a \in \Mc$. Возьмём  предикат $P_i(x)
\in \Pc$. Сделаем предикат $P_i^{(a)}(x) := \case{P_i(x), & P_i(a)=1;\\ \ol{P_i(x)}, & P_i(a)=0.}$ Имеем
$P_i^{(a)}(a)=1$. Построим предикат $P^{(a)}(x) := P_1^{(a)}(x) \& \dots \& P_s^{(a)}(x)$.
Он обладает двумя свойствами: $P^{(a)}(a)=1$ и $P^{(a)}(b)=0$, если $b\neq a$, поскольку по
условию $\exi \; P_j \in \Pc\cln P_j(a) \bw\neq P_j(b)$, и он присутствует в выражении для $P^{(a)}(x)$. Таким
образом, построен аналог функции $x^\si$. Теперь для любого предиката построим аналог СДНФ.

Пусть $P(x)$\т любой предикат. Пусть $\Tc=\hc{a \in \Mc: P(a)=1}$. Тогда наш предикат выражается  формулой
$P(x)=\bigvee\limits_{a \in \Tc}P^{(a)}(x)$. Здесь очень существенно то, что $|\Mc| < \infty$, иначе
подобная формула не имела бы смысла.
\end{proof}

\subsection{Кванторы и формулы}

Рассмотрим предикат $P(x,y)$. \emph{Навешиванием квантора общности} на $P$ называется получение из  него
предиката $Q(y)=\fa x P(x,y)$, такого, что $Q(y)=1$ $\Lra$ для любого $x \in \Mc$ имеем $P(x,y)=1$.
\emph{Навешиванием квантора существования} называется получение предиката $R(y)=\exi x P(x,y)$, такого,
что $R(y)=1$ $\Lra$ существует $x \in \Mc$, для которого $P(x,y)=1$.

Определим понятие формулы, а также связанных и свободных переменных в ней. Грубо говоря,  \emph{свободные
переменные} в формуле\т это такие переменные, вместо которых имеет смысл подставлять некоторые значения.
\emph{Связанные переменные} возникают в формуле при навешивании кванторов или других так называемых
\emph{связывающих операторов}, например, $\int \ldots dx$. Они обладают тем свойством, что вместо этих
переменных бессмысленно подставлять конкретные значения: $\exi x P(x) \rightsquigarrow \exi \; 1 P(1)$\т
эта <<формула>> смысла не имеет. Теперь дадим строгое определение \emph{формулы}.

\begin{df}

\pt{1} Любой предикат $P(\X{1}{n})$ является формулой. При этом $X =\hc{\X{1}{n}}$\т множество свободных переменных, а
множество связанных переменных $Y$ пусто.

\pt{2} Если $F_1$ и $F_2$\т формулы, а для их свободных и
связанных переменных верно $X_1 \cap Y_2 = \es$ и $X_2 \cap Y_1 = \es$, то $F_1 \&
F_2$, $F_1 \vee F_2$\т тоже формулы, и их множества свободных и связанных переменных равны соответственно $X
= X_1 \cup X_2$, $Y = Y_1 \cup Y_2$. Вычисление происходит по правилу $F\evn{R}=F_1\evn{R} \&
F_2\evn{R}$, для дизъюнкции\т аналогично. $\ol{F}_1$ также является формулой с множествами свободных и
связанных переменных $X_1$ и $Y_1$ соответственно.

\pt{3} Если $F$\т формула, $X$ и $Y$\т её
свободные и связанные переменные, $x \in X$ (для определённости пусть $x$\т последняя переменная функции
$F$), то навешиванием квантора общности получаем формулу $F' = \fa x F$, и при этом $X'=X \wo \hc{x}$, $Y' = Y \cup \hc{x}$. Вычисление происходит так: $F'(\Al{1}{t})=1$ $\Lra$ $F(\Al{1}{t},x)=1$ при
любом значении $x$. Аналогично строится формула $F''= \exi x F$, где $X'' = X \wo \hc{x}$, а $Y'' = Y \cup \hc{x}$.
\end{df}

\begin{df}
\emph{Интерпретация}\т задание значения (смысла) математических выражений (символов, формул и т.д.)  В
математике такими значениями служат математические объекты (математические операции, выражения и т.п).
\emph{Моделью} называется интерпретация, в которой выполнен заданный набор аксиом.
\end{df}

\begin{df}
Формула называется \emph{истинной в модели}, если для всех наборов значений свободных переменных она принимает значение 1.
\end{df}

\begin{ex}
Пусть в нашей модели
$P_2(x)$, $P_3(x)$, $P_6(x)$\т предикаты делимости соответственно на $2$, на $3$ и на $6$. Тогда формула $P_2(x)
\& P_3(x) \ra P_6(x)$ истинна в этой модели. Если бы мы придали символам $P_i(x)$ другой смысл (выбрали бы
другую модель), то эта формула могла бы быть и не истинной в этой новой модели.
\end{ex}

\begin{df}
Формула \emph{истинна на множестве}, если она истинна в любой модели на данном множестве.
\end{df}

\begin{ex}
$\exi x A(x) \ra \fa x A(x)$\т не всегда верна, но верна на любом множестве из одного элемента.
\end{ex}

\begin{df}
\emph{Тождественно истинная} формула\т формула, истинная для любого множества.
\end{df}

\subsection{Эквивалентные формулы и нормальный вид формулы}

Формулы могут быть \emph{эквивалентными} (в модели/на множестве/тождественно).

\begin{ex}
$P_2(x) \& P_3(x)$ и $P_6(x)$
эквивалентны в модели, в которой $P_k$ обозначает делимость на $k$, формулы $\exi x A(x)$ и $\fa x
A(x)$ эквивалентны на одноэлементном множестве, а $A(x)$ и $\ol{\ol{A(x)}}$  тождественно эквивалентны.
\end{ex}

Сформулируем правила эквивалентного преобразования формул.

В любой формуле можно переименовать связанную переменную, не нарушая связанности остальных.

\begin{stm}
$\ol{\fa x A(x)}=\exi x \ol{A(x)}$.
\end{stm}

\begin{proof}
Пусть первая формула (обозначим её $F$) равна 1.
Тогда существует $x \in \Mc$, для которого $A(x)=0$.  (Если бы для всех $x$ $A(x)=1$, то $\fa x A(x)=1$
$\Ra$ $F=0$, что невозможно). Но это и означает, что $\exi x \ol{A(x)}$, \те верна вторая формула.
Аналогично разбирается второй случай, когда $F=0$.
\end{proof}

\begin{stm}
$\ol{\exi x A(x)} = \fa x \ol{A(x)}$.
\end{stm}
\begin{proof}
Доказательство аналогично предыдущему.
\end{proof}

\begin{stm}
Рассмотрим формулу $A(x) \vee B$, причём $x$\т свободная переменная для $A$ и $x$ не входит в $B$.
Тогда формулы $\fa x \br{A(x)\vee B}$ и $\fa x A(x) \vee B$ эквивалентны.
\end{stm}

\begin{proof}
Рассмотрим
набор $\tal=(\Al{1}{t})$. Если $B\evn{\tal}=1$, то $\br{A(x) \vee B}\evn{\tal}=1$, и это верно
для любого $x$, значит имеем $\fa x \br{A(x)\vee B}\evn{\tal}=1$. Но в то же время истинна и
вторая формула. Если же $B\evn{\tal}=0$, то это соотношение никак не зависит от $x$, откуда при любом $x$
имеем $\br{A(x) \vee B}\evn{\tal} = A(x)\evn{\tal}$. Тогда первая формула преобразуется к виду
$\fa x A(x)$. Но точно к такому же виду приводится и вторая формула, поскольку $B\evn{\tal}=0$.
\end{proof}

При тех же условиях имеются следующие равенства:
\eqn{\fa x A(x)\& B = \fa x \br{A(x) \& B}, \quad
\exi x A(x) \vee B = \exi x \br{A(x) \vee B}, \quad
\exi x A(x) \& B = \exi x \br{A(x) \& B }.}

\begin{theorem}
Любую формулу можно эквивалентными преобразованиями привести к нормальной форме, в которой все
кванторы вынесены в начало формулы.
\end{theorem}

\begin{proof}
Сначала переносим отрицания под кванторы, затем переименовываем
связанные кванторами переменные так, чтобы все они были различными. Далее, используя правила из предыдущего
утверждения, выносим все кванторы наружу, после чего формула принимает нормальный вид.
\end{proof}

\begin{ex}
$\fa x A(x) \vee \exi x B(x)=\fa x A(x) \vee \exi y B(y) =\fa x \exi y \br{A(x) \vee B(y) }$.
\end{ex}

\section{Алгоритмы}

\subsection{Машина Тьюринга}

\begin{df}
\emph{Алгоритм}\т чётко описанная процедура преобразования информации, приводящая к результату.
\end{df}

Представим себе бесконечную в обе стороны ленту, разбитую на ячейки. Представим себе устройство, способное
двигаться по ячейкам вправо и влево, а также способное считывать и записывать информацию в ячейке, над
которой оно в данный момент находится. В ячейках могут быть записаны символы некоторого конечного алфавита
$A$. Устройство обладает некоторым конечным набором состояний $Q = \hc{q_0, q_1, \dots, q_n}$. Вся эта
конструкция называется \emph{машиной Тьюринга}.

Программа для машины Тьюринга представляет собой конечный список команд вида $aq \ra a'q' D$, где $a, a' \in
A$, $q, q' \in Q$, $D \in \hc{L \, S \, R}$. Команда расшифровывается так: если машина была в состоянии $q$ и
считанный с ленты в данный момент символ  равен $a$, то машина переходит в состояние $q'$, печатает на
текущей клетке символ $a'$ и затем выполняет одно из трёх действий: если $D=L$, то машина смещается на одну
клетку влево, если $D=R$, то на одну клетку вправо, если $D=S$, то машина никуда не смещается. Необходимо,
чтобы в программе не было разных команд с одинаковыми входами вида $aq\ra a'_1q'_1D_1$ и $aq\ra a'_2q'_2D_2$
-- это противоречит однозначности алгоритма. Заметим также, что порядок расположения команд программы, в
отличие от привычных языков программирования, может быть произвольным.

Изначально машина находится в состоянии $q_1$. Если машина пришла в состояние $q_0$, то она останавливается.

Введём понятие \emph{применимости} машины к входным данным, записанным на ленте до начала её работы.

\begin{df}
Машина называется \emph{применимой} к некоторой записи на ленте, если при работе над этой записью после
конечного числа шагов она остановится. Если она никогда не остановится, то машина называется неприменимой к
этой записи.
\end{df}

\begin{ex}
Рассмотрим машины $\wt{M}:a_iq_i \ra a_i q_iS$ и $M:a_iq_i \ra a_i q_0S$. Как нетрудно
видеть, $\wt{M}$ над любой записью будет работать вечно, а $M$ сразу остановится при любых входных данных.
Таким образом, $\wt{M}$ неприменима ни к одному входу, а $M$ применима к любому входу.
\end{ex}

Машину Тьюринга удобно применять при вычислении функций вида $f:\mathbb{N}^k \ra \mathbb{N}^m$. Введём
правила записи чисел на ленте. Пусть наш алфавит состоит из символов 0 и 1. Тогда число $n$ будем записывать
с помощью последовательности из $n+1$ единицы, а набор $(n_1,n_2 \sco n_k)$ в виде $0\underbrace{11 \dots
1}_{n_1+1}0\underbrace{11 \dots 1}_{n_2+1}0 \dots 0\underbrace{11 \dots 1}_{n_k+1}0$.

\begin{ex}
Составим машину, прибавляющую к числу на ленте 1. Она дойдёт до конца массива из единиц,
поставит туда 1 и вернется назад. Вот её код:
\begin{center}
$\mat{
1 & q_1 & \ra & 1 & q_1 & R \\
0 & q_1 & \ra & 1 & q_2 & L \\}\qquad\qquad
\mat{
1 & q_2 & \ra & 1 & q_2 & L \\
0 & q_2 & \ra & 0 & q_0 & R}$
\end{center}
\end{ex}

\begin{df}
Говорят, что машина $M$ \emph{вычисляет} функцию $f(\X{1}{k}):\mathbb{N}^k\ra \mathbb{N}^m$, если на любом
наборе $(\Al{1}{k}) \in \Dc(f)$ машина останавливается и на ленте остаётся результат
$(\Bt{1}{m})=f(\Al{1}{k})$, а в случае $(\Al{1}{k}) \notin \Dc(f)$ она работает вечно, \те неприменима к
таким входным записям.
\end{df}

\begin{ex}
Машина, которая топчется на месте, вычисляет нигде не определенную функцию.
\end{ex}

Рассмотрим алфавит $A = \hc{a_1\sco a_k}$ и символ-разделитель $\triangle \notin A$. Построим машину
$M_D$, удваивающую слова, помещая между ними разделитель: $a_{i_1}\sco a_{i_n} \mapsto a_{i_1}\sco a_{i_n}
\triangle \; a_{i_1}\sco a_{i_n}$. Для этого добавим к алфавиту символы $\hc{b_1\sco b_k}$, не входящие в
алфавит $A \cup \hc{\triangle}$. Код машины $M_D$:
\begin{center}$\mat{
q_1    & a_i & \ra & q_{2i} & b_i & R \\
q_{2i} & a_j & \ra & q_{2i} & b_j & R \\
q_{2i} & 0   & \ra & q_{3i} & \triangle & R \\
q_{2i} & \triangle & \ra & q_{3i} & \triangle & R \\
q_{3i} & 0   & \ra & q_4    & a_i & L \\}
\qquad\qquad\mat{
q_{3i} & a_j & \ra & q_{3i} & a_j & R \\
q_4    & a_j & \ra & q_4    & a_j & L \\
q_4    & \triangle & \ra & q_5    & \triangle & L \\
q_5    & a_i & \ra & q_5    & a_i & L \\
q_5    & b_i & \ra & q_1    & b_i & R \\}
\qquad\qquad\mat{
q_1    & \triangle & \ra & q_6    & \triangle & L \\
q_6    & b_j & \ra & q_6    & a_j & L \\
q_6    & 0   & \ra & q_0    & 0   & R \\ \\ \\}$
\end{center}

Построим универсальную кодировку программы машины
Тьюринга. Занумеруем алфавит $\hc{\sA{0}{k}}$,  состояния $q_0 \sco q_m$ и сдвиги натуральными
числами:
\ctab{|c|c|c|c|c|c|c|c|c|c|c|}{
\hline $R$ & $L$ & $S$ & $a_0$ & $a_1$ & $\dots$ & $a_k$  & $q_0$ & $q_1$ & $\dots$ & $q_m$ \\
\hline 1   & 3   & 5   & 7     & 9     & $\dots$ & $2k+7$ & 0     & 2     & $\dots$ & $2m$  \\
\hline}
Тогда любую команду можно закодировать набором из 5 чисел, а этот набор
представить на ленте в помощью  алфавита $\hc{1,*}$ стандартным образом, помещая вместо разделяющих
нулей символ $*$. При этом мы получим код команды (обозначим его через $K$). Теперь можно составить
код всей программы $K(M)=K_1 * K_2 * \dots * K_s$, где $K_i$\т коды всех команд программы. Заметим,
что по слову $K(M)$ всегда можно восстановить программу.

Пусть в алфавите наших машин содержатся символы 1 и $*$. Тогда можно подсунуть машине в качестве исходных
данных её собственный код.

\begin{df}
Машина, которая работает над собственным кодом и останавливается, называется
\emph{самоприменимой}. Если машина при этом не останавливается, она называется \emph{несамоприменимой}.
\end{df}

\subsection{Алгоритмически неразрешимые проблемы}

Зададимся вопросом: существует ли машина $M_S$, которая по коду любой машины $M$ определяет,
самоприменима ли она? Если она существует, она должна быть применима к коду любой машины $M$ и
должна останавливаться на клетке с 1 в случае самоприменимости $M$, и на клетке с 0 в противном случае.

\begin{theorem}
$M_S$ не существует, то есть проблема самоприменимости алгоритмически неразрешима.
\end{theorem}

\begin{proof}
Пусть $M_S$ существует. Тогда построим машину $\wt{M}$,
неприменимую к коду самоприменимых машин и применимую к коду несамоприменимых машин, добавлением к $M_S$ двух
команд: $q_0 0 \ra q_0' 0 S$ и $q_0 1 \ra q_0 1 S$. При этом $q_0$ сделаем «обычным» состоянием $\wt{M}$, а
некоторое новое состояние $q_0'$ сделаем для неё стоповым. Применим $\wt{M}$ саму к себе. Она не может быть
самоприменимой, поскольку в этом случае $M_S$ выдаст 1, и $\wt{M}$ зациклится. Но она не может быть и
несамоприменимой, поскольку в этом случае $M_S$ выдаст 0, и она остановится. Противоречие, значит $M_S$ не
существует.
\end{proof}

Поставим вопрос: существует ли машина $M_P$, определяющая, применима ли некоторая машина $M$ к входным
данным $B$. Входные данные $M_P$\т код вида $K(M) \triangle B$.

\begin{theorem}
Машина $M_P$ не существует, \те проблема применимости алгоритмически неразрешима.
\end{theorem}

\begin{proof}
Пусть существует $M_P$. Присоединим к ней спереди машину
удвоения слова $M_D$. Подсунем ей в качестве входных данных код $K(M)$. Она удвоит его, и затем решит,
применима ли $M$ к $K(M)$, то есть решит проблему самоприменимости, что невозможно. Противоречие.
\end{proof}

В заключение приведём без доказательства более общую теорему.

\begin{theorem}[Райса]
Задача определения того, обладает ли некоторый объект нетривиальным свойством, алгоритмически
неразрешима. Свойство называется нетривиальным, если существуют объекты, обладающие им, и
объекты, не обладающие им.
\end{theorem}

\end{document}
